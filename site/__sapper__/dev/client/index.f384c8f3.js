import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, D as validate_each_argument, v as validate_slots, ae as afterUpdate, aa as Icon, e as element, p as space, a as claim_element, b as children, q as claim_space, f as detach_dev, g as attr_dev, O as toggle_class, h as add_location, j as insert_dev, w as append_dev, t as transition_in, I as group_outros, k as transition_out, J as check_outros, F as destroy_each, y as listen_dev, T as run_all, H as binding_callbacks, l as create_component, m as claim_component, n as mount_component, o as destroy_component, ac as HtmlTag, G as onMount, A as text, K as query_selector_all, B as claim_text } from './client.2d8aba47.js';
import { g as getFragment } from './navigation.84703ebc.js';

/* node_modules/@sveltejs/site-kit/components/GuideContents.svelte generated by Svelte v3.31.0 */
const file = "node_modules/@sveltejs/site-kit/components/GuideContents.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

// (115:4) {#if section.slug === active_section}
function create_if_block_1(ctx) {
	let div;
	let icon;
	let current;

	icon = new Icon({
			props: { name: "arrow-right" },
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(icon.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "icon-container svelte-mm3tjv");
			add_location(div, file, 115, 5, 2146);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(icon, div, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(115:4) {#if section.slug === active_section}",
		ctx
	});

	return block;
}

// (132:5) {#if subsection.slug === active_section}
function create_if_block(ctx) {
	let div;
	let icon;
	let current;

	icon = new Icon({
			props: { name: "arrow-right" },
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(icon.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "icon-container svelte-mm3tjv");
			add_location(div, file, 132, 6, 2612);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(icon, div, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(132:5) {#if subsection.slug === active_section}",
		ctx
	});

	return block;
}

// (122:3) {#each section.subsections as subsection}
function create_each_block_1(ctx) {
	let a;
	let html_tag;
	let raw_value = /*subsection*/ ctx[12].title + "";
	let t;
	let a_href_value;
	let a_data_level_value;
	let current;
	let if_block = /*subsection*/ ctx[12].slug === /*active_section*/ ctx[2] && create_if_block(ctx);

	const block = {
		c: function create() {
			a = element("a");
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", {
				class: true,
				href: true,
				"data-level": true
			});

			var a_nodes = children(a);
			t = claim_space(a_nodes);
			if (if_block) if_block.l(a_nodes);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			html_tag = new HtmlTag(t);
			attr_dev(a, "class", "subsection svelte-mm3tjv");
			attr_dev(a, "href", a_href_value = "" + (/*dir*/ ctx[3] + "#" + /*subsection*/ ctx[12].slug));
			attr_dev(a, "data-level", a_data_level_value = /*subsection*/ ctx[12].level);
			toggle_class(a, "active", /*subsection*/ ctx[12].slug === /*active_section*/ ctx[2]);
			add_location(a, file, 123, 4, 2366);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			html_tag.m(raw_value, a);
			append_dev(a, t);
			if (if_block) if_block.m(a, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*sections*/ 2) && raw_value !== (raw_value = /*subsection*/ ctx[12].title + "")) html_tag.p(raw_value);

			if (/*subsection*/ ctx[12].slug === /*active_section*/ ctx[2]) {
				if (if_block) {
					if (dirty & /*sections, active_section*/ 6) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(a, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*dir, sections*/ 10 && a_href_value !== (a_href_value = "" + (/*dir*/ ctx[3] + "#" + /*subsection*/ ctx[12].slug))) {
				attr_dev(a, "href", a_href_value);
			}

			if (!current || dirty & /*sections*/ 2 && a_data_level_value !== (a_data_level_value = /*subsection*/ ctx[12].level)) {
				attr_dev(a, "data-level", a_data_level_value);
			}

			if (dirty & /*sections, active_section*/ 6) {
				toggle_class(a, "active", /*subsection*/ ctx[12].slug === /*active_section*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(122:3) {#each section.subsections as subsection}",
		ctx
	});

	return block;
}

// (110:1) {#each sections as section}
function create_each_block(ctx) {
	let li;
	let a;
	let html_tag;
	let raw_value = /*section*/ ctx[9].metadata.title + "";
	let t0;
	let a_href_value;
	let t1;
	let t2;
	let current;
	let if_block = /*section*/ ctx[9].slug === /*active_section*/ ctx[2] && create_if_block_1(ctx);
	let each_value_1 = /*section*/ ctx[9].subsections;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { class: true, href: true });
			var a_nodes = children(a);
			t0 = claim_space(a_nodes);
			if (if_block) if_block.l(a_nodes);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(li_nodes);
			}

			t2 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			html_tag = new HtmlTag(t0);
			attr_dev(a, "class", "section svelte-mm3tjv");
			attr_dev(a, "href", a_href_value = "" + (/*dir*/ ctx[3] + "#" + /*section*/ ctx[9].slug));
			toggle_class(a, "active", /*section*/ ctx[9].slug === /*active_section*/ ctx[2]);
			add_location(a, file, 111, 3, 1966);
			attr_dev(li, "class", "svelte-mm3tjv");
			add_location(li, file, 110, 2, 1958);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			html_tag.m(raw_value, a);
			append_dev(a, t0);
			if (if_block) if_block.m(a, null);
			append_dev(li, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(li, null);
			}

			append_dev(li, t2);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*sections*/ 2) && raw_value !== (raw_value = /*section*/ ctx[9].metadata.title + "")) html_tag.p(raw_value);

			if (/*section*/ ctx[9].slug === /*active_section*/ ctx[2]) {
				if (if_block) {
					if (dirty & /*sections, active_section*/ 6) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(a, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*dir, sections*/ 10 && a_href_value !== (a_href_value = "" + (/*dir*/ ctx[3] + "#" + /*section*/ ctx[9].slug))) {
				attr_dev(a, "href", a_href_value);
			}

			if (dirty & /*sections, active_section*/ 6) {
				toggle_class(a, "active", /*section*/ ctx[9].slug === /*active_section*/ ctx[2]);
			}

			if (dirty & /*dir, sections, active_section*/ 14) {
				each_value_1 = /*section*/ ctx[9].subsections;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(li, t2);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(110:1) {#each sections as section}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let ul_1;
	let current;
	let mounted;
	let dispose;
	let each_value = /*sections*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			ul_1 = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul_1 = claim_element(nodes, "UL", { class: true });
			var ul_1_nodes = children(ul_1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_1_nodes);
			}

			ul_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul_1, "class", "reference-toc svelte-mm3tjv");
			add_location(ul_1, file, 103, 0, 1771);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul_1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul_1, null);
			}

			/*ul_1_binding*/ ctx[6](ul_1);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(ul_1, "mouseenter", /*mouseenter_handler*/ ctx[7], false, false, false),
					listen_dev(ul_1, "mouseleave", /*mouseleave_handler*/ ctx[8], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*sections, dir, active_section*/ 14) {
				each_value = /*sections*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul_1, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul_1);
			destroy_each(each_blocks, detaching);
			/*ul_1_binding*/ ctx[6](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GuideContents", slots, []);
	let { sections = [] } = $$props;
	let { active_section = null } = $$props;
	let { show_contents } = $$props;
	let { prevent_sidebar_scroll = false } = $$props;
	let { dir } = $$props;
	let ul;

	afterUpdate(() => {
		// bit of a hack — prevent sidebar scrolling if
		// TOC is open on mobile, or scroll came from within sidebar
		if (prevent_sidebar_scroll || show_contents && window.innerWidth < 832) return;

		const active = ul.querySelector(".active");

		if (active) {
			const { top, bottom } = active.getBoundingClientRect();
			const min = 200;
			const max = window.innerHeight - 200;

			if (top > max) {
				ul.parentNode.scrollBy({
					top: top - max,
					left: 0,
					behavior: "smooth"
				});
			} else if (bottom < min) {
				ul.parentNode.scrollBy({
					top: bottom - min,
					left: 0,
					behavior: "smooth"
				});
			}
		}
	});

	const writable_props = ["sections", "active_section", "show_contents", "prevent_sidebar_scroll", "dir"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GuideContents> was created with unknown prop '${key}'`);
	});

	function ul_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			ul = $$value;
			$$invalidate(4, ul);
		});
	}

	const mouseenter_handler = () => $$invalidate(0, prevent_sidebar_scroll = true);
	const mouseleave_handler = () => $$invalidate(0, prevent_sidebar_scroll = false);

	$$self.$$set = $$props => {
		if ("sections" in $$props) $$invalidate(1, sections = $$props.sections);
		if ("active_section" in $$props) $$invalidate(2, active_section = $$props.active_section);
		if ("show_contents" in $$props) $$invalidate(5, show_contents = $$props.show_contents);
		if ("prevent_sidebar_scroll" in $$props) $$invalidate(0, prevent_sidebar_scroll = $$props.prevent_sidebar_scroll);
		if ("dir" in $$props) $$invalidate(3, dir = $$props.dir);
	};

	$$self.$capture_state = () => ({
		afterUpdate,
		Icon,
		sections,
		active_section,
		show_contents,
		prevent_sidebar_scroll,
		dir,
		ul
	});

	$$self.$inject_state = $$props => {
		if ("sections" in $$props) $$invalidate(1, sections = $$props.sections);
		if ("active_section" in $$props) $$invalidate(2, active_section = $$props.active_section);
		if ("show_contents" in $$props) $$invalidate(5, show_contents = $$props.show_contents);
		if ("prevent_sidebar_scroll" in $$props) $$invalidate(0, prevent_sidebar_scroll = $$props.prevent_sidebar_scroll);
		if ("dir" in $$props) $$invalidate(3, dir = $$props.dir);
		if ("ul" in $$props) $$invalidate(4, ul = $$props.ul);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		prevent_sidebar_scroll,
		sections,
		active_section,
		dir,
		ul,
		show_contents,
		ul_1_binding,
		mouseenter_handler,
		mouseleave_handler
	];
}

class GuideContents extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			sections: 1,
			active_section: 2,
			show_contents: 5,
			prevent_sidebar_scroll: 0,
			dir: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GuideContents",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*show_contents*/ ctx[5] === undefined && !("show_contents" in props)) {
			console.warn("<GuideContents> was created without expected prop 'show_contents'");
		}

		if (/*dir*/ ctx[3] === undefined && !("dir" in props)) {
			console.warn("<GuideContents> was created without expected prop 'dir'");
		}
	}

	get sections() {
		throw new Error("<GuideContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sections(value) {
		throw new Error("<GuideContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active_section() {
		throw new Error("<GuideContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active_section(value) {
		throw new Error("<GuideContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_contents() {
		throw new Error("<GuideContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_contents(value) {
		throw new Error("<GuideContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get prevent_sidebar_scroll() {
		throw new Error("<GuideContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set prevent_sidebar_scroll(value) {
		throw new Error("<GuideContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dir() {
		throw new Error("<GuideContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dir(value) {
		throw new Error("<GuideContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/@sveltejs/site-kit/components/Docs.svelte generated by Svelte v3.31.0 */
const file$1 = "node_modules/@sveltejs/site-kit/components/Docs.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (386:1) {#each sections as section}
function create_each_block$1(ctx) {
	let section;
	let h2;
	let span;
	let span_id_value;
	let t0;
	let a0;
	let a0_href_value;
	let t1;
	let html_tag;
	let raw0_value = /*section*/ ctx[14].metadata.title + "";
	let t2;
	let small;
	let a1;
	let icon;
	let a1_href_value;
	let t3;
	let html_tag_1;
	let raw1_value = /*section*/ ctx[14].html + "";
	let t4;
	let section_data_id_value;
	let current;
	icon = new Icon({ props: { name: "edit" }, $$inline: true });

	const block = {
		c: function create() {
			section = element("section");
			h2 = element("h2");
			span = element("span");
			t0 = space();
			a0 = element("a");
			t1 = space();
			t2 = space();
			small = element("small");
			a1 = element("a");
			create_component(icon.$$.fragment);
			t3 = space();
			t4 = space();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { "data-id": true, class: true });
			var section_nodes = children(section);
			h2 = claim_element(section_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			span = claim_element(h2_nodes, "SPAN", { class: true, id: true });
			children(span).forEach(detach_dev);
			t0 = claim_space(h2_nodes);

			a0 = claim_element(h2_nodes, "A", {
				href: true,
				class: true,
				"aria-hidden": true
			});

			children(a0).forEach(detach_dev);
			t1 = claim_space(h2_nodes);
			t2 = claim_space(h2_nodes);
			small = claim_element(h2_nodes, "SMALL", { class: true });
			var small_nodes = children(small);
			a1 = claim_element(small_nodes, "A", { href: true, title: true, class: true });
			var a1_nodes = children(a1);
			claim_component(icon.$$.fragment, a1_nodes);
			a1_nodes.forEach(detach_dev);
			small_nodes.forEach(detach_dev);
			h2_nodes.forEach(detach_dev);
			t3 = claim_space(section_nodes);
			t4 = claim_space(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "offset-anchor");
			attr_dev(span, "id", span_id_value = /*section*/ ctx[14].slug);
			add_location(span, file$1, 388, 4, 7766);
			attr_dev(a0, "href", a0_href_value = "" + (/*dir*/ ctx[3] + "#" + /*section*/ ctx[14].slug));
			attr_dev(a0, "class", "anchor");
			attr_dev(a0, "aria-hidden", "");
			add_location(a0, file$1, 391, 4, 7873);
			html_tag = new HtmlTag(t2);
			attr_dev(a1, "href", a1_href_value = "https://github.com/" + /*owner*/ ctx[0] + "/" + /*project*/ ctx[1] + "/edit/master" + /*path*/ ctx[2] + "/" + /*dir*/ ctx[3] + "/" + /*section*/ ctx[14].file);
			attr_dev(a1, "title", /*edit_title*/ ctx[4]);
			attr_dev(a1, "class", "svelte-1itkhys");
			add_location(a1, file$1, 395, 5, 7989);
			attr_dev(small, "class", "svelte-1itkhys");
			add_location(small, file$1, 394, 4, 7976);
			attr_dev(h2, "class", "svelte-1itkhys");
			add_location(h2, file$1, 387, 3, 7757);
			html_tag_1 = new HtmlTag(t4);
			attr_dev(section, "data-id", section_data_id_value = /*section*/ ctx[14].slug);
			attr_dev(section, "class", "svelte-1itkhys");
			add_location(section, file$1, 386, 2, 7721);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, h2);
			append_dev(h2, span);
			append_dev(h2, t0);
			append_dev(h2, a0);
			append_dev(h2, t1);
			html_tag.m(raw0_value, h2);
			append_dev(h2, t2);
			append_dev(h2, small);
			append_dev(small, a1);
			mount_component(icon, a1, null);
			append_dev(section, t3);
			html_tag_1.m(raw1_value, section);
			append_dev(section, t4);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*sections*/ 32 && span_id_value !== (span_id_value = /*section*/ ctx[14].slug)) {
				attr_dev(span, "id", span_id_value);
			}

			if (!current || dirty & /*dir, sections*/ 40 && a0_href_value !== (a0_href_value = "" + (/*dir*/ ctx[3] + "#" + /*section*/ ctx[14].slug))) {
				attr_dev(a0, "href", a0_href_value);
			}

			if ((!current || dirty & /*sections*/ 32) && raw0_value !== (raw0_value = /*section*/ ctx[14].metadata.title + "")) html_tag.p(raw0_value);

			if (!current || dirty & /*owner, project, path, dir, sections*/ 47 && a1_href_value !== (a1_href_value = "https://github.com/" + /*owner*/ ctx[0] + "/" + /*project*/ ctx[1] + "/edit/master" + /*path*/ ctx[2] + "/" + /*dir*/ ctx[3] + "/" + /*section*/ ctx[14].file)) {
				attr_dev(a1, "href", a1_href_value);
			}

			if (!current || dirty & /*edit_title*/ 16) {
				attr_dev(a1, "title", /*edit_title*/ ctx[4]);
			}

			if ((!current || dirty & /*sections*/ 32) && raw1_value !== (raw1_value = /*section*/ ctx[14].html + "")) html_tag_1.p(raw1_value);

			if (!current || dirty & /*sections*/ 32 && section_data_id_value !== (section_data_id_value = /*section*/ ctx[14].slug)) {
				attr_dev(section, "data-id", section_data_id_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(386:1) {#each sections as section}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div0;
	let t0;
	let aside_1;
	let div1;
	let guidecontents;
	let t1;
	let button;
	let icon;
	let current;
	let mounted;
	let dispose;
	let each_value = /*sections*/ ctx[5];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	guidecontents = new GuideContents({
			props: {
				sections: /*sections*/ ctx[5],
				active_section: /*active_section*/ ctx[6],
				show_contents: /*show_contents*/ ctx[9],
				dir: /*dir*/ ctx[3]
			},
			$$inline: true
		});

	icon = new Icon({
			props: {
				name: /*show_contents*/ ctx[9] ? "close" : "menu"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			aside_1 = element("aside");
			div1 = element("div");
			create_component(guidecontents.$$.fragment);
			t1 = space();
			button = element("button");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			aside_1 = claim_element(nodes, "ASIDE", { class: true });
			var aside_1_nodes = children(aside_1);
			div1 = claim_element(aside_1_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(guidecontents.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			t1 = claim_space(aside_1_nodes);
			button = claim_element(aside_1_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			claim_component(icon.$$.fragment, button_nodes);
			button_nodes.forEach(detach_dev);
			aside_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "content listify svelte-1itkhys");
			add_location(div0, file$1, 384, 0, 7638);
			attr_dev(div1, "class", "sidebar svelte-1itkhys");
			add_location(div1, file$1, 407, 1, 8291);
			attr_dev(button, "class", "svelte-1itkhys");
			add_location(button, file$1, 411, 1, 8460);
			attr_dev(aside_1, "class", "sidebar-container svelte-1itkhys");
			toggle_class(aside_1, "open", /*show_contents*/ ctx[9]);
			add_location(aside_1, file$1, 406, 0, 8211);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			/*div0_binding*/ ctx[10](div0);
			insert_dev(target, t0, anchor);
			insert_dev(target, aside_1, anchor);
			append_dev(aside_1, div1);
			mount_component(guidecontents, div1, null);
			append_dev(aside_1, t1);
			append_dev(aside_1, button);
			mount_component(icon, button, null);
			/*aside_1_binding*/ ctx[13](aside_1);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div1, "click", /*click_handler*/ ctx[11], false, false, false),
					listen_dev(button, "click", /*click_handler_1*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*sections, owner, project, path, dir, edit_title*/ 63) {
				each_value = /*sections*/ ctx[5];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div0, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const guidecontents_changes = {};
			if (dirty & /*sections*/ 32) guidecontents_changes.sections = /*sections*/ ctx[5];
			if (dirty & /*active_section*/ 64) guidecontents_changes.active_section = /*active_section*/ ctx[6];
			if (dirty & /*show_contents*/ 512) guidecontents_changes.show_contents = /*show_contents*/ ctx[9];
			if (dirty & /*dir*/ 8) guidecontents_changes.dir = /*dir*/ ctx[3];
			guidecontents.$set(guidecontents_changes);
			const icon_changes = {};
			if (dirty & /*show_contents*/ 512) icon_changes.name = /*show_contents*/ ctx[9] ? "close" : "menu";
			icon.$set(icon_changes);

			if (dirty & /*show_contents*/ 512) {
				toggle_class(aside_1, "open", /*show_contents*/ ctx[9]);
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(guidecontents.$$.fragment, local);
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(guidecontents.$$.fragment, local);
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_each(each_blocks, detaching);
			/*div0_binding*/ ctx[10](null);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(aside_1);
			destroy_component(guidecontents);
			destroy_component(icon);
			/*aside_1_binding*/ ctx[13](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Docs", slots, []);
	let { owner = "sveltejs" } = $$props;
	let { project = "svelte" } = $$props;
	let { path = "/site/content" } = $$props;
	let { dir = "docs" } = $$props;
	let { edit_title = "edit this section" } = $$props;
	let { sections } = $$props;
	let active_section;
	let container;
	let aside;
	let show_contents = false;

	onMount(() => {
		// don't update `active_section` for headings above level 4, see _sections.js
		const anchors = container.querySelectorAll("[id]:not([data-scrollignore])");

		let positions;

		const onresize = () => {
			const { top } = container.getBoundingClientRect();

			positions = [].map.call(anchors, anchor => {
				return anchor.getBoundingClientRect().top - top;
			});
		};

		let last_id = getFragment();

		const onscroll = () => {
			const { top } = container.getBoundingClientRect();
			let i = anchors.length;

			while (i--) {
				if (positions[i] + top < 40) {
					const anchor = anchors[i];
					const { id } = anchor;

					if (id !== last_id) {
						$$invalidate(6, active_section = id);
						last_id = id;
					}

					return;
				}
			}
		};

		window.addEventListener("scroll", onscroll, true);
		window.addEventListener("resize", onresize, true);

		// wait for fonts to load...
		const timeouts = [setTimeout(onresize, 1000), setTimeout(onscroll, 5000)];

		onresize();
		onscroll();

		return () => {
			window.removeEventListener("scroll", onscroll, true);
			window.removeEventListener("resize", onresize, true);
			timeouts.forEach(timeout => clearTimeout(timeout));
		};
	});

	const writable_props = ["owner", "project", "path", "dir", "edit_title", "sections"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Docs> was created with unknown prop '${key}'`);
	});

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(7, container);
		});
	}

	const click_handler = () => $$invalidate(9, show_contents = false);
	const click_handler_1 = () => $$invalidate(9, show_contents = !show_contents);

	function aside_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			aside = $$value;
			$$invalidate(8, aside);
		});
	}

	$$self.$$set = $$props => {
		if ("owner" in $$props) $$invalidate(0, owner = $$props.owner);
		if ("project" in $$props) $$invalidate(1, project = $$props.project);
		if ("path" in $$props) $$invalidate(2, path = $$props.path);
		if ("dir" in $$props) $$invalidate(3, dir = $$props.dir);
		if ("edit_title" in $$props) $$invalidate(4, edit_title = $$props.edit_title);
		if ("sections" in $$props) $$invalidate(5, sections = $$props.sections);
	};

	$$self.$capture_state = () => ({
		onMount,
		GuideContents,
		Icon,
		getFragment,
		owner,
		project,
		path,
		dir,
		edit_title,
		sections,
		active_section,
		container,
		aside,
		show_contents
	});

	$$self.$inject_state = $$props => {
		if ("owner" in $$props) $$invalidate(0, owner = $$props.owner);
		if ("project" in $$props) $$invalidate(1, project = $$props.project);
		if ("path" in $$props) $$invalidate(2, path = $$props.path);
		if ("dir" in $$props) $$invalidate(3, dir = $$props.dir);
		if ("edit_title" in $$props) $$invalidate(4, edit_title = $$props.edit_title);
		if ("sections" in $$props) $$invalidate(5, sections = $$props.sections);
		if ("active_section" in $$props) $$invalidate(6, active_section = $$props.active_section);
		if ("container" in $$props) $$invalidate(7, container = $$props.container);
		if ("aside" in $$props) $$invalidate(8, aside = $$props.aside);
		if ("show_contents" in $$props) $$invalidate(9, show_contents = $$props.show_contents);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		owner,
		project,
		path,
		dir,
		edit_title,
		sections,
		active_section,
		container,
		aside,
		show_contents,
		div0_binding,
		click_handler,
		click_handler_1,
		aside_1_binding
	];
}

class Docs extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			owner: 0,
			project: 1,
			path: 2,
			dir: 3,
			edit_title: 4,
			sections: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Docs",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*sections*/ ctx[5] === undefined && !("sections" in props)) {
			console.warn("<Docs> was created without expected prop 'sections'");
		}
	}

	get owner() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set owner(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get project() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set project(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get path() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set path(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dir() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dir(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get edit_title() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set edit_title(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sections() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sections(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/docs/index.svelte generated by Svelte v3.31.0 */
const file$2 = "src/routes/docs/index.svelte";

function create_fragment$2(ctx) {
	let meta0;
	let meta1;
	let meta2;
	let t0;
	let h1;
	let t1;
	let t2;
	let docs;
	let current;

	docs = new Docs({
			props: { sections: /*sections*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			meta0 = element("meta");
			meta1 = element("meta");
			meta2 = element("meta");
			t0 = space();
			h1 = element("h1");
			t1 = text("API Docs");
			t2 = space();
			create_component(docs.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-i2j3de\"]", document.head);
			meta0 = claim_element(head_nodes, "META", { name: true, content: true });
			meta1 = claim_element(head_nodes, "META", { name: true, content: true });
			meta2 = claim_element(head_nodes, "META", { name: true, content: true });
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, "API Docs");
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			claim_component(docs.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "API Docs • Svelte";
			attr_dev(meta0, "name", "twitter:title");
			attr_dev(meta0, "content", "Svelte API docs");
			add_location(meta0, file$2, 16, 1, 305);
			attr_dev(meta1, "name", "twitter:description");
			attr_dev(meta1, "content", "Cybernetically enhanced web apps");
			add_location(meta1, file$2, 17, 1, 360);
			attr_dev(meta2, "name", "Description");
			attr_dev(meta2, "content", "Cybernetically enhanced web apps");
			add_location(meta2, file$2, 18, 1, 438);
			attr_dev(h1, "class", "visually-hidden");
			add_location(h1, file$2, 21, 0, 523);
		},
		m: function mount(target, anchor) {
			append_dev(document.head, meta0);
			append_dev(document.head, meta1);
			append_dev(document.head, meta2);
			insert_dev(target, t0, anchor);
			insert_dev(target, h1, anchor);
			append_dev(h1, t1);
			insert_dev(target, t2, anchor);
			mount_component(docs, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const docs_changes = {};
			if (dirty & /*sections*/ 1) docs_changes.sections = /*sections*/ ctx[0];
			docs.$set(docs_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(docs.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(docs.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			detach_dev(meta0);
			detach_dev(meta1);
			detach_dev(meta2);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t2);
			destroy_component(docs, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload() {
	const sections = await this.fetch(`docs.json`).then(r => r.json());
	return { sections };
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Docs", slots, []);
	let { sections } = $$props;
	const writable_props = ["sections"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Docs> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("sections" in $$props) $$invalidate(0, sections = $$props.sections);
	};

	$$self.$capture_state = () => ({ preload, Docs, sections });

	$$self.$inject_state = $$props => {
		if ("sections" in $$props) $$invalidate(0, sections = $$props.sections);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [sections];
}

class Docs_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { sections: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Docs_1",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*sections*/ ctx[0] === undefined && !("sections" in props)) {
			console.warn("<Docs> was created without expected prop 'sections'");
		}
	}

	get sections() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sections(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Docs_1;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZjM4NGM4ZjMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc2l0ZS1raXQvY29tcG9uZW50cy9HdWlkZUNvbnRlbnRzLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc2l0ZS1raXQvY29tcG9uZW50cy9Eb2NzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZG9jcy9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cblx0aW1wb3J0IHsgYWZ0ZXJVcGRhdGUgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IHNlY3Rpb25zID0gW107XG5cdGV4cG9ydCBsZXQgYWN0aXZlX3NlY3Rpb24gPSBudWxsO1xuXHRleHBvcnQgbGV0IHNob3dfY29udGVudHM7XG5cdGV4cG9ydCBsZXQgcHJldmVudF9zaWRlYmFyX3Njcm9sbCA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGRpcjtcblxuXHRsZXQgdWw7XG5cblx0YWZ0ZXJVcGRhdGUoKCkgPT4ge1xuXHRcdC8vIGJpdCBvZiBhIGhhY2sg4oCUwqBwcmV2ZW50IHNpZGViYXIgc2Nyb2xsaW5nIGlmXG5cdFx0Ly8gVE9DIGlzIG9wZW4gb24gbW9iaWxlLCBvciBzY3JvbGwgY2FtZSBmcm9tIHdpdGhpbiBzaWRlYmFyXG5cdFx0aWYgKHByZXZlbnRfc2lkZWJhcl9zY3JvbGwgfHwgc2hvd19jb250ZW50cyAmJiB3aW5kb3cuaW5uZXJXaWR0aCA8IDgzMikgcmV0dXJuO1xuXG5cdFx0Y29uc3QgYWN0aXZlID0gdWwucXVlcnlTZWxlY3RvcignLmFjdGl2ZScpO1xuXG5cdFx0aWYgKGFjdGl2ZSkge1xuXHRcdFx0Y29uc3QgeyB0b3AsIGJvdHRvbSB9ID0gYWN0aXZlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0XHRjb25zdCBtaW4gPSAyMDA7XG5cdFx0XHRjb25zdCBtYXggPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSAyMDA7XG5cblx0XHRcdGlmICh0b3AgPiBtYXgpIHtcblx0XHRcdFx0dWwucGFyZW50Tm9kZS5zY3JvbGxCeSh7XG5cdFx0XHRcdFx0dG9wOiB0b3AgLSBtYXgsXG5cdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRiZWhhdmlvcjogJ3Ntb290aCdcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgaWYgKGJvdHRvbSA8IG1pbikge1xuXHRcdFx0XHR1bC5wYXJlbnROb2RlLnNjcm9sbEJ5KHtcblx0XHRcdFx0XHR0b3A6IGJvdHRvbSAtIG1pbixcblx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdGJlaGF2aW9yOiAnc21vb3RoJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0LnJlZmVyZW5jZS10b2MgbGkge1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdGxpbmUtaGVpZ2h0OiAxLjI7XG5cdFx0bWFyZ2luOiAwIDAgNHJlbSAwO1xuXHR9XG5cblx0YSB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdHRyYW5zaXRpb246IGNvbG9yIDAuMnM7XG5cdFx0Ym9yZGVyLWJvdHRvbTogbm9uZTtcblx0XHRwYWRkaW5nOiAwO1xuXHRcdGNvbG9yOiB2YXIoLS1zZWNvbmQpO1xuXHR9XG5cblx0LnNlY3Rpb24ge1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmc6IDAgMCAuOHJlbSAwO1xuXHRcdGZvbnQtc2l6ZTogdmFyKC0taDYpO1xuXHRcdHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG5cdFx0bGV0dGVyLXNwYWNpbmc6IDAuMWVtO1xuXHRcdGZvbnQtd2VpZ2h0OiA2MDA7XG5cdH1cblxuXHQuc3Vic2VjdGlvbiB7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0Zm9udC1zaXplOiAxLjZyZW07XG5cdFx0Zm9udC1mYW1pbHk6IHZhcigtLWZvbnQpO1xuXHRcdHBhZGRpbmc6IDAgMCAwLjZlbSAwO1xuXHR9XG5cblx0LnNlY3Rpb246aG92ZXIsXG5cdC5zdWJzZWN0aW9uOmhvdmVyLFxuXHQuYWN0aXZlIHtcblx0XHRjb2xvcjogdmFyKC0tZmxhc2gpO1xuXHR9XG5cblx0LnN1YnNlY3Rpb25bZGF0YS1sZXZlbD1cIjRcIl0ge1xuXHRcdHBhZGRpbmctbGVmdDogMS4ycmVtO1xuXHR9XG5cblx0Lmljb24tY29udGFpbmVyIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAtLjJyZW07XG5cdFx0cmlnaHQ6IDIuNHJlbTtcblx0fVxuXG5cdEBtZWRpYSAobWluLXdpZHRoOiA4MzJweCkge1xuXHRcdGEge1xuXHRcdFx0Y29sb3I6IHZhcigtLXNpZGViYXItdGV4dCk7XG5cdFx0fVxuXG5cdFx0YTpob3Zlcixcblx0XHQuc2VjdGlvbjpob3Zlcixcblx0XHQuc3Vic2VjdGlvbjpob3Zlcixcblx0XHQuYWN0aXZlIHtcblx0XHRcdGNvbG9yOiB3aGl0ZVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPHVsXG5cdGJpbmQ6dGhpcz17dWx9XG5cdGNsYXNzPVwicmVmZXJlbmNlLXRvY1wiXG5cdG9uOm1vdXNlZW50ZXI9XCJ7KCkgPT4gcHJldmVudF9zaWRlYmFyX3Njcm9sbCA9IHRydWV9XCJcblx0b246bW91c2VsZWF2ZT1cInsoKSA9PiBwcmV2ZW50X3NpZGViYXJfc2Nyb2xsID0gZmFsc2V9XCJcbj5cblx0eyNlYWNoIHNlY3Rpb25zIGFzIHNlY3Rpb259XG5cdFx0PGxpPlxuXHRcdFx0PGEgY2xhc3M9XCJzZWN0aW9uXCIgY2xhc3M6YWN0aXZlPVwie3NlY3Rpb24uc2x1ZyA9PT0gYWN0aXZlX3NlY3Rpb259XCIgaHJlZj1cIntkaXJ9I3tzZWN0aW9uLnNsdWd9XCI+XG5cdFx0XHRcdHtAaHRtbCBzZWN0aW9uLm1ldGFkYXRhLnRpdGxlfVxuXG5cdFx0XHRcdHsjaWYgc2VjdGlvbi5zbHVnID09PSBhY3RpdmVfc2VjdGlvbn1cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaWNvbi1jb250YWluZXJcIj5cblx0XHRcdFx0XHRcdDxJY29uIG5hbWU9XCJhcnJvdy1yaWdodFwiIC8+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdHsvaWZ9XG5cdFx0XHQ8L2E+XG5cblx0XHRcdHsjZWFjaCBzZWN0aW9uLnN1YnNlY3Rpb25zIGFzIHN1YnNlY3Rpb259XG5cdFx0XHRcdDwhLS0gc2VlIDxzY3JpcHQ+IGJlbG93OiBvbjpjbGljaz0nc2Nyb2xsVG8oZXZlbnQsIHN1YnNlY3Rpb24uc2x1ZyknIC0tPlxuXHRcdFx0XHQ8YVxuXHRcdFx0XHRcdGNsYXNzPVwic3Vic2VjdGlvblwiXG5cdFx0XHRcdFx0Y2xhc3M6YWN0aXZlPVwie3N1YnNlY3Rpb24uc2x1ZyA9PT0gYWN0aXZlX3NlY3Rpb259XCJcblx0XHRcdFx0XHRocmVmPVwie2Rpcn0je3N1YnNlY3Rpb24uc2x1Z31cIlxuXHRcdFx0XHRcdGRhdGEtbGV2ZWw9XCJ7c3Vic2VjdGlvbi5sZXZlbH1cIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0e0BodG1sIHN1YnNlY3Rpb24udGl0bGV9XG5cblx0XHRcdFx0XHR7I2lmIHN1YnNlY3Rpb24uc2x1ZyA9PT0gYWN0aXZlX3NlY3Rpb259XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaWNvbi1jb250YWluZXJcIj5cblx0XHRcdFx0XHRcdFx0PEljb24gbmFtZT1cImFycm93LXJpZ2h0XCIgLz5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdDwvYT5cblx0XHRcdHsvZWFjaH1cblx0XHQ8L2xpPlxuXHR7L2VhY2h9XG48L3VsPlxuIiwiPHNjcmlwdD5cblx0aW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCBHdWlkZUNvbnRlbnRzIGZyb20gJy4vR3VpZGVDb250ZW50cy5zdmVsdGUnOyAvLyBUT0RPIHJlbmFtZVxuXHRpbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uc3ZlbHRlJztcblx0aW1wb3J0IHsgZ2V0RnJhZ21lbnQgfSBmcm9tICcuLi91dGlscy9uYXZpZ2F0aW9uJztcblxuXHRleHBvcnQgbGV0IG93bmVyID0gJ3N2ZWx0ZWpzJztcblx0ZXhwb3J0IGxldCBwcm9qZWN0ID0gJ3N2ZWx0ZSc7XG5cdGV4cG9ydCBsZXQgcGF0aCA9ICcvc2l0ZS9jb250ZW50Jztcblx0ZXhwb3J0IGxldCBkaXIgPSAnZG9jcyc7XG5cdGV4cG9ydCBsZXQgZWRpdF90aXRsZSA9ICdlZGl0IHRoaXMgc2VjdGlvbic7XG5cdGV4cG9ydCBsZXQgc2VjdGlvbnM7XG5cdGxldCBhY3RpdmVfc2VjdGlvbjtcblxuXHRsZXQgY29udGFpbmVyO1xuXHRsZXQgYXNpZGU7XG5cdGxldCBzaG93X2NvbnRlbnRzID0gZmFsc2U7XG5cblx0b25Nb3VudCgoKSA9PiB7XG5cdFx0Ly8gZG9uJ3QgdXBkYXRlIGBhY3RpdmVfc2VjdGlvbmAgZm9yIGhlYWRpbmdzIGFib3ZlIGxldmVsIDQsIHNlZSBfc2VjdGlvbnMuanNcblx0XHRjb25zdCBhbmNob3JzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF06bm90KFtkYXRhLXNjcm9sbGlnbm9yZV0pJyk7XG5cblx0XHRsZXQgcG9zaXRpb25zO1xuXG5cdFx0Y29uc3Qgb25yZXNpemUgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCB7IHRvcCB9ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0cG9zaXRpb25zID0gW10ubWFwLmNhbGwoYW5jaG9ycywgYW5jaG9yID0+IHtcblx0XHRcdFx0cmV0dXJuIGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSB0b3A7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRsZXQgbGFzdF9pZCA9IGdldEZyYWdtZW50KCk7XG5cblx0XHRjb25zdCBvbnNjcm9sbCA9ICgpID0+IHtcblx0XHRcdGNvbnN0IHsgdG9wIH0gPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdGxldCBpID0gYW5jaG9ycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdGlmIChwb3NpdGlvbnNbaV0gKyB0b3AgPCA0MCkge1xuXHRcdFx0XHRcdGNvbnN0IGFuY2hvciA9IGFuY2hvcnNbaV07XG5cdFx0XHRcdFx0Y29uc3QgeyBpZCB9ID0gYW5jaG9yO1xuXG5cdFx0XHRcdFx0aWYgKGlkICE9PSBsYXN0X2lkKSB7XG5cdFx0XHRcdFx0XHRhY3RpdmVfc2VjdGlvbiA9IGlkO1xuXHRcdFx0XHRcdFx0bGFzdF9pZCA9IGlkO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25zY3JvbGwsIHRydWUpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbnJlc2l6ZSwgdHJ1ZSk7XG5cblx0XHQvLyB3YWl0IGZvciBmb250cyB0byBsb2FkLi4uXG5cdFx0Y29uc3QgdGltZW91dHMgPSBbXG5cdFx0XHRzZXRUaW1lb3V0KG9ucmVzaXplLCAxMDAwKSxcblx0XHRcdHNldFRpbWVvdXQob25zY3JvbGwsIDUwMDApXG5cdFx0XTtcblxuXHRcdG9ucmVzaXplKCk7XG5cdFx0b25zY3JvbGwoKTtcblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25zY3JvbGwsIHRydWUpO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9ucmVzaXplLCB0cnVlKTtcblxuXHRcdFx0dGltZW91dHMuZm9yRWFjaCh0aW1lb3V0ID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG5cdFx0fTtcblx0fSk7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHRhc2lkZSB7XG5cdFx0cG9zaXRpb246IGZpeGVkO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXHRcdGxlZnQ6IDAuOHJlbTtcblx0XHRib3R0b206IDAuOHJlbTtcblx0XHR3aWR0aDogMmVtO1xuXHRcdGhlaWdodDogMmVtO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0Ym9yZGVyOiAxcHggc29saWQgI2VlZTtcblx0XHRib3gtc2hhZG93OiAxcHggMXB4IDZweCByZ2JhKDAsMCwwLDAuMSk7XG5cdFx0dHJhbnNpdGlvbjogd2lkdGggMC4ycywgaGVpZ2h0IDAuMnM7XG5cdH1cblxuXHRhc2lkZSBidXR0b24ge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRib3R0b206IDA7XG5cdFx0bGVmdDogMDtcblx0XHR3aWR0aDogMy40cmVtO1xuXHRcdGhlaWdodDogMy40cmVtO1xuXHR9XG5cblx0YXNpZGUub3BlbiB7XG5cdFx0d2lkdGg6IGNhbGMoMTAwdncgLSAzcmVtKTtcblx0XHRoZWlnaHQ6IGNhbGMoMTAwdmggLSB2YXIoLS1uYXYtaCkpO1xuXHR9XG5cblx0YXNpZGUub3Blbjo6YmVmb3JlIHtcblx0XHRjb250ZW50OiAnJztcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0d2lkdGg6IGNhbGMoMTAwJSAtIDJyZW0pO1xuXHRcdGhlaWdodDogMmVtO1xuXHRcdGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byB0b3AsIHJnYmEoMjU1LDI1NSwyNTUsMCkgMCUsIHJnYmEoMjU1LDI1NSwyNTUsMC43KSA1MCUsIHJnYmEoMjU1LDI1NSwyNTUsMSkgMTAwJSk7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0ei1pbmRleDogMjtcblx0fVxuXG5cdGFzaWRlOjphZnRlciB7XG5cdFx0Y29udGVudDogJyc7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdGxlZnQ6IDA7XG5cdFx0Ym90dG9tOiAxLjllbTtcblx0XHR3aWR0aDogY2FsYygxMDAlIC0gMnJlbSk7XG5cdFx0aGVpZ2h0OiAyZW07XG5cdFx0YmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgcmdiYSgyNTUsMjU1LDI1NSwwKSAwJSwgcmdiYSgyNTUsMjU1LDI1NSwwLjcpIDUwJSwgcmdiYSgyNTUsMjU1LDI1NSwxKSAxMDAlKTtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0fVxuXG5cdC5zaWRlYmFyIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0Zm9udC1mYW1pbHk6IHZhcigtLWZvbnQpO1xuXHRcdG92ZXJmbG93LXk6IGF1dG87XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdHBhZGRpbmc6IDRlbSAxLjZyZW0gMmVtIDMuMnJlbTtcblx0XHRib3R0b206IDJlbTtcblx0fVxuXG5cdC5jb250ZW50IHtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogdmFyKC0tdG9wLW9mZnNldCkgdmFyKC0tc2lkZS1uYXYpO1xuXHRcdHRhYi1zaXplOiAyO1xuXHRcdC1tb3otdGFiLXNpemU6IDI7XG5cdH1cblxuXHRAbWVkaWEgKG1pbi13aWR0aDogODMycHgpIHsgLyogY2FuJ3QgdXNlIHZhcnMgaW4gQG1lZGlhIDooICovXG5cdFx0YXNpZGUge1xuXHRcdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0XHR3aWR0aDogdmFyKC0tc2lkZWJhci13KTtcblx0XHRcdGhlaWdodDogMTAwdmg7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRsZWZ0OiAwO1xuXHRcdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRcdGJveC1zaGFkb3c6IG5vbmU7XG5cdFx0XHRib3JkZXI6IG5vbmU7XG5cdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kKTtcblx0XHRcdGNvbG9yOiB3aGl0ZTtcblx0XHR9XG5cblx0XHRhc2lkZS5vcGVuOjpiZWZvcmUge1xuXHRcdFx0ZGlzcGxheTogbm9uZTtcblx0XHR9XG5cblx0XHRhc2lkZTo6YWZ0ZXIge1xuXHRcdFx0Y29udGVudDogJyc7XG5cdFx0XHRib3R0b206IDA7XG5cdFx0XHRoZWlnaHQ6IHZhcigtLXRvcC1vZmZzZXQpO1xuXHRcdFx0YmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgcmdiYSgxMDMsMTAzLDEyMCwwKSAwJSwgcmdiYSgxMDMsMTAzLDEyMCwwLjcpIDUwJSwgcmdiYSgxMDMsMTAzLDEyMCwxKSAxMDAlKTtcblx0XHR9XG5cblx0XHRhc2lkZSBidXR0b24ge1xuXHRcdFx0ZGlzcGxheTogbm9uZTtcblx0XHR9XG5cblx0XHQuc2lkZWJhciB7XG5cdFx0XHRwYWRkaW5nOiB2YXIoLS10b3Atb2Zmc2V0KSAwIDYuNHJlbSAzLjJyZW07XG5cdFx0XHRmb250LWZhbWlseTogdmFyKC0tZm9udCk7XG5cdFx0XHRvdmVyZmxvdy15OiBhdXRvO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0Ym90dG9tOiBhdXRvO1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0fVxuXG5cdFx0LmNvbnRlbnQge1xuXHRcdFx0cGFkZGluZy1sZWZ0OiBjYWxjKHZhcigtLXNpZGViYXItdykgKyB2YXIoLS1zaWRlLW5hdikpO1xuXHRcdH1cblxuXHRcdC5jb250ZW50IDpnbG9iYWwoLnNpZGUtYnktc2lkZSkge1xuXHRcdFx0ZGlzcGxheTogZ3JpZDtcblx0XHRcdGdyaWQtdGVtcGxhdGUtY29sdW1uczogY2FsYyg1MCUgLSAwLjVlbSkgY2FsYyg1MCUgLSAwLjVlbSk7XG5cdFx0XHRncmlkLWdhcDogMWVtO1xuXHRcdH1cblxuXHRcdC5jb250ZW50IDpnbG9iYWwoLnNpZGUtYnktc2lkZSkgOmdsb2JhbCguY29kZSkge1xuXHRcdFx0cGFkZGluZzogMWVtIDA7XG5cdFx0fVxuXHR9XG5cblx0LmNvbnRlbnQgaDIge1xuXHRcdG1hcmdpbi10b3A6IDhyZW07XG5cdFx0cGFkZGluZzogMnJlbSAxLjZyZW0gNHJlbSAwLjJyZW07XG5cdFx0Ym9yZGVyLXRvcDogdmFyKC0tYm9yZGVyLXcpIHNvbGlkICM2NzY3Nzg1YjsgLyogYmFzZWQgb24gLS1zZWNvbmQgKi9cblx0XHRjb2xvcjogdmFyKC0tdGV4dCk7XG5cdFx0bGluZS1oZWlnaHQ6IDE7XG5cdFx0Zm9udC1zaXplOiB2YXIoLS1oMyk7XG5cdFx0bGV0dGVyLXNwYWNpbmc6IC4wNWVtO1xuXHRcdHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG5cdH1cblxuXHQuY29udGVudCBzZWN0aW9uOmZpcnN0LW9mLXR5cGUgPiBoMiB7XG5cdFx0bWFyZ2luLXRvcDogMDtcblx0fVxuXG5cdC5jb250ZW50IDpnbG9iYWwoaDQpIHtcblx0XHRtYXJnaW46IDJlbSAwIDFlbSAwO1xuXHR9XG5cblx0LmNvbnRlbnQgOmdsb2JhbCgub2Zmc2V0LWFuY2hvcikge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHR0b3A6IGNhbGMoLTEgKiAodmFyKC0tbmF2LWgpICsgdmFyKC0tdG9wLW9mZnNldCkgLSAxcmVtKSk7XG5cdFx0d2lkdGg6IDA7XG5cdFx0aGVpZ2h0OiAwO1xuXHR9XG5cblx0LmNvbnRlbnQgOmdsb2JhbCguYW5jaG9yKSB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdGJhY2tncm91bmQ6IHVybCgvaWNvbnMvbGluay5zdmcpIDAgNTAlIG5vLXJlcGVhdDtcblx0XHRiYWNrZ3JvdW5kLXNpemU6IDFlbSAxZW07XG5cdFx0d2lkdGg6IDEuNGVtO1xuXHRcdGhlaWdodDogMWVtO1xuXHRcdGxlZnQ6IC0xLjNlbTtcblx0XHRvcGFjaXR5OiAwO1xuXHRcdHRyYW5zaXRpb246IG9wYWNpdHkgMC4ycztcblx0XHRib3JkZXI6IG5vbmUgIWltcG9ydGFudDsgLyogVE9ETyBnZXQgcmlkIG9mIGxpbmtpZnkgKi9cblx0fVxuXG5cdC5jb250ZW50IDpnbG9iYWwoaDIgPiAuYW5jaG9yKSxcblx0LmNvbnRlbnQgOmdsb2JhbChoMyA+IC5hbmNob3IpIHtcblx0XHR0b3A6IDAuNzVlbTtcblx0fVxuXG5cdEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xuXHRcdC5jb250ZW50IDpnbG9iYWwoaDIpOmhvdmVyIDpnbG9iYWwoLmFuY2hvciksXG5cdFx0LmNvbnRlbnQgOmdsb2JhbChoMyk6aG92ZXIgOmdsb2JhbCguYW5jaG9yKSxcblx0XHQuY29udGVudCA6Z2xvYmFsKGg0KTpob3ZlciA6Z2xvYmFsKC5hbmNob3IpLFxuXHRcdC5jb250ZW50IDpnbG9iYWwoaDUpOmhvdmVyIDpnbG9iYWwoLmFuY2hvciksXG5cdFx0LmNvbnRlbnQgOmdsb2JhbChoNik6aG92ZXIgOmdsb2JhbCguYW5jaG9yKSB7XG5cdFx0XHRvcGFjaXR5OiAxO1xuXHRcdH1cblxuXHRcdC5jb250ZW50IDpnbG9iYWwoaDUpIDpnbG9iYWwoLmFuY2hvciksXG5cdFx0LmNvbnRlbnQgOmdsb2JhbChoNikgOmdsb2JhbCguYW5jaG9yKSB7XG5cdFx0XHR0b3A6IDAuMjVlbTtcblx0XHR9XG5cdH1cblxuXHQuY29udGVudCA6Z2xvYmFsKGgzKSxcblx0LmNvbnRlbnQgOmdsb2JhbChoMyA+IGNvZGUpIHtcblx0XHRtYXJnaW46IDYuNHJlbSAwIDAgMDtcblx0XHRwYWRkaW5nOiAycmVtIDEuNnJlbSA1LjZyZW0gLjJyZW07XG5cdFx0Y29sb3I6IHZhcigtLXRleHQpO1xuXHRcdGJvcmRlci10b3A6IHZhcigtLWJvcmRlci13KSBzb2xpZCAjNjc2Nzc4MWY7IC8qIGJhc2VkIG9uIC0tc2Vjb25kICovXG5cdFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG5cdFx0bGluZS1oZWlnaHQ6IDE7XG5cdH1cblxuXHQuY29udGVudCA6Z2xvYmFsKGgzKTpmaXJzdC1vZi10eXBlIHtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0bWFyZ2luOiAwO1xuXHR9XG5cblx0LyogYXZvaWQgZG91YmxlZCBib3JkZXItdG9wICovXG5cdC5jb250ZW50IDpnbG9iYWwoaDMgPiBjb2RlKSB7XG5cdFx0Ym9yZGVyLXJhZGl1czogMCAwIDAgMDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Zm9udC1zaXplOiBpbmhlcml0O1xuXHR9XG5cblxuXHQuY29udGVudCA6Z2xvYmFsKGg0KSxcblx0LmNvbnRlbnQgOmdsb2JhbChoNCA+IGNvZGUpIHtcblx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRmb250LXdlaWdodDogNjAwO1xuXHRcdGZvbnQtc2l6ZTogMi40cmVtO1xuXHRcdGNvbG9yOiB2YXIoLS1zZWNvbmQpO1xuXHRcdG1hcmdpbjogNi40cmVtIDAgMS42cmVtIDA7XG5cdFx0cGFkZGluZy1sZWZ0OiAwO1xuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHRcdGxpbmUtaGVpZ2h0OiAxO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0dG9wOiAwO1xuXHR9XG5cblx0LmNvbnRlbnQgOmdsb2JhbChoNCA+IGVtKSB7XG5cdFx0b3BhY2l0eTogMC43O1xuXHR9XG5cblx0LmNvbnRlbnQgOmdsb2JhbChoNCA+IC5hbmNob3IpIHtcblx0XHR0b3A6IDAuMDVlbTtcblx0fVxuXG5cdC5jb250ZW50IDpnbG9iYWwoaDUpIHtcblx0XHRmb250LXNpemU6IDIuNHJlbTtcblx0XHRtYXJnaW46IDJlbSAwIDAuNWVtIDA7XG5cdH1cblxuXHQuY29udGVudCA6Z2xvYmFsKGNvZGUpIHtcblx0XHRwYWRkaW5nOiAuM3JlbSAuOHJlbSAuM3JlbTtcblx0XHRtYXJnaW46IDAgMC4ycmVtO1xuXHRcdHRvcDogLS4xcmVtO1xuXHRcdGJhY2tncm91bmQ6IHZhcigtLWJhY2stYXBpKTtcblx0fVxuXG5cdC5jb250ZW50IDpnbG9iYWwocHJlKSA6Z2xvYmFsKGNvZGUpIHtcblx0XHRwYWRkaW5nOiAwO1xuXHRcdG1hcmdpbjogMDtcblx0XHR0b3A6IDA7XG5cdFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG5cdH1cblxuXHQuY29udGVudCA6Z2xvYmFsKHByZSkge1xuXHRcdG1hcmdpbjogMCAwIDJlbSAwO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0fVxuXG5cdC5jb250ZW50IDpnbG9iYWwoLmljb24pIHtcblx0XHR3aWR0aDogMnJlbTtcblx0XHRoZWlnaHQ6IDJyZW07XG5cdFx0c3Ryb2tlOiBjdXJyZW50Q29sb3I7XG5cdFx0c3Ryb2tlLXdpZHRoOiAyO1xuXHRcdHN0cm9rZS1saW5lY2FwOiByb3VuZDtcblx0XHRzdHJva2UtbGluZWpvaW46IHJvdW5kO1xuXHRcdGZpbGw6IG5vbmU7XG5cdH1cblxuXHQuY29udGVudCA6Z2xvYmFsKHRhYmxlKSB7XG5cdFx0bWFyZ2luOiAwIDAgMmVtIDA7XG5cdH1cblxuXHRzZWN0aW9uID4gOmdsb2JhbCguY29kZS1ibG9jaykgPiA6Z2xvYmFsKHByZSkge1xuXHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0XHQvKiBiYWNrZ3JvdW5kOiB2YXIoLS1iYWNrLWFwaSk7ICovXG5cdFx0Y29sb3I6IHdoaXRlO1xuXHRcdHBhZGRpbmc6IC4zcmVtIC44cmVtO1xuXHRcdG1hcmdpbjogMDtcblx0XHRtYXgtd2lkdGg6IDEwMCU7XG5cdH1cblxuXHRzZWN0aW9uID4gOmdsb2JhbCguY29kZS1ibG9jayk+IDpnbG9iYWwocHJlLmxhbmd1YWdlLW1hcmt1cCkge1xuXHRcdHBhZGRpbmc6IC4zcmVtIC44cmVtIC4ycmVtO1xuXHRcdGJhY2tncm91bmQ6IHZhcigtLWJhY2stYXBpKTtcblx0fVxuXG5cdHNlY3Rpb24gPiA6Z2xvYmFsKHApIHtcblx0XHRtYXgtd2lkdGg6IHZhcigtLWxpbmVtYXgpXG5cdH1cblxuXHRzZWN0aW9uIDpnbG9iYWwocCkge1xuXHRcdG1hcmdpbjogMWVtIDA7XG5cdH1cblxuXHRzbWFsbCB7XG5cdFx0Zm9udC1zaXplOiB2YXIoLS1oNSk7XG5cdFx0ZmxvYXQ6IHJpZ2h0O1xuXHRcdHBvaW50ZXItZXZlbnRzOiBhbGw7XG5cdFx0Y29sb3I6IHZhcigtLXByaW1lKTtcblx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdH1cblxuXHQvKiBubyBsaW5raWZ5IG9uIHRoZXNlICovXG5cdHNtYWxsIGEgICAgICAgIHsgYWxsOiB1bnNldCB9XG5cdHNtYWxsIGE6YmVmb3JlIHsgYWxsOiB1bnNldCB9XG5cblx0c2VjdGlvbiA6Z2xvYmFsKGJsb2NrcXVvdGUpIHtcblx0XHRjb2xvcjogaHNsKDIwNCwgMTAwJSwgNTAlKTtcblx0XHRib3JkZXI6IDJweCBzb2xpZCB2YXIoLS1mbGFzaCk7XG5cdH1cblxuXHRzZWN0aW9uIDpnbG9iYWwoYmxvY2txdW90ZSkgOmdsb2JhbChjb2RlKSB7XG5cdFx0YmFja2dyb3VuZDogaHNsKDIwNCwgMTAwJSwgOTUlKSAhaW1wb3J0YW50O1xuXHRcdGNvbG9yOiBoc2woMjA0LCAxMDAlLCA1MCUpO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGJpbmQ6dGhpcz17Y29udGFpbmVyfSBjbGFzcz1cImNvbnRlbnQgbGlzdGlmeVwiPlxuXHR7I2VhY2ggc2VjdGlvbnMgYXMgc2VjdGlvbn1cblx0XHQ8c2VjdGlvbiBkYXRhLWlkPXtzZWN0aW9uLnNsdWd9PlxuXHRcdFx0PGgyPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm9mZnNldC1hbmNob3JcIiBpZD17c2VjdGlvbi5zbHVnfT48L3NwYW4+XG5cblx0XHRcdFx0PCEtLSBzdmVsdGUtaWdub3JlIGExMXktbWlzc2luZy1jb250ZW50IC0tPlxuXHRcdFx0XHQ8YSBocmVmPVwie2Rpcn0je3NlY3Rpb24uc2x1Z31cIiBjbGFzcz1cImFuY2hvclwiIGFyaWEtaGlkZGVuPjwvYT5cblxuXHRcdFx0XHR7QGh0bWwgc2VjdGlvbi5tZXRhZGF0YS50aXRsZX1cblx0XHRcdFx0PHNtYWxsPlxuXHRcdFx0XHRcdDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20ve293bmVyfS97cHJvamVjdH0vZWRpdC9tYXN0ZXJ7cGF0aH0ve2Rpcn0ve3NlY3Rpb24uZmlsZX1cIiB0aXRsZT1cIntlZGl0X3RpdGxlfVwiPlxuXHRcdFx0XHRcdFx0PEljb24gbmFtZT0nZWRpdCcgLz5cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdDwvc21hbGw+XG5cdFx0XHQ8L2gyPlxuXG5cdFx0XHR7QGh0bWwgc2VjdGlvbi5odG1sfVxuXHRcdDwvc2VjdGlvbj5cblx0ey9lYWNofVxuPC9kaXY+XG5cbjxhc2lkZSBiaW5kOnRoaXM9e2FzaWRlfSBjbGFzcz1cInNpZGViYXItY29udGFpbmVyXCIgY2xhc3M6b3Blbj17c2hvd19jb250ZW50c30+XG5cdDxkaXYgY2xhc3M9XCJzaWRlYmFyXCIgb246Y2xpY2s9XCJ7KCkgPT4gc2hvd19jb250ZW50cyA9IGZhbHNlfVwiPiA8IS0tIHNjcm9sbCBjb250YWluZXIgLS0+XG5cdFx0PEd1aWRlQ29udGVudHMge3NlY3Rpb25zfSB7YWN0aXZlX3NlY3Rpb259IHtzaG93X2NvbnRlbnRzfSB7ZGlyfSAvPlxuXHQ8L2Rpdj5cblxuXHQ8YnV0dG9uIG9uOmNsaWNrPVwieygpID0+IHNob3dfY29udGVudHMgPSAhc2hvd19jb250ZW50c31cIj5cblx0XHQ8SWNvbiBuYW1lPVwie3Nob3dfY29udGVudHM/ICdjbG9zZScgOiAnbWVudSd9XCIvPlxuXHQ8L2J1dHRvbj5cbjwvYXNpZGU+XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cblx0ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG5cdFx0Y29uc3Qgc2VjdGlvbnMgPSBhd2FpdCB0aGlzLmZldGNoKGBkb2NzLmpzb25gKS50aGVuKHIgPT4gci5qc29uKCkpO1xuXHRcdHJldHVybiB7IHNlY3Rpb25zIH07XG5cdH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuXHRpbXBvcnQgeyBEb2NzIH0gZnJvbSAnQHN2ZWx0ZWpzL3NpdGUta2l0JztcblxuXHRleHBvcnQgbGV0IHNlY3Rpb25zO1xuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6aGVhZD5cblx0PHRpdGxlPkFQSSBEb2NzIOKAoiBTdmVsdGU8L3RpdGxlPlxuXG5cdDxtZXRhIG5hbWU9XCJ0d2l0dGVyOnRpdGxlXCIgY29udGVudD1cIlN2ZWx0ZSBBUEkgZG9jc1wiPlxuXHQ8bWV0YSBuYW1lPVwidHdpdHRlcjpkZXNjcmlwdGlvblwiIGNvbnRlbnQ9XCJDeWJlcm5ldGljYWxseSBlbmhhbmNlZCB3ZWIgYXBwc1wiPlxuXHQ8bWV0YSBuYW1lPVwiRGVzY3JpcHRpb25cIiBjb250ZW50PVwiQ3liZXJuZXRpY2FsbHkgZW5oYW5jZWQgd2ViIGFwcHNcIj5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxoMSBjbGFzcz1cInZpc3VhbGx5LWhpZGRlblwiPkFQSSBEb2NzPC9oMT5cbjxEb2NzIHtzZWN0aW9uc30vPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDQWlJWSxHQUFVLEtBQUMsS0FBSzs7Ozs7K0JBRWxCLEdBQVUsS0FBQyxJQUFJLHdCQUFLLEdBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0RBTGhDLEdBQUcsMkJBQUcsR0FBVSxLQUFDLElBQUk7aUVBQ2YsR0FBVSxLQUFDLEtBQUs7NENBRmQsR0FBVSxLQUFDLElBQUksd0JBQUssR0FBYzs7Ozs7Ozs7Ozs7eUZBSTFDLEdBQVUsS0FBQyxLQUFLOztzQkFFbEIsR0FBVSxLQUFDLElBQUksd0JBQUssR0FBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tHQUxoQyxHQUFHLDJCQUFHLEdBQVUsS0FBQyxJQUFJOzs7O3lHQUNmLEdBQVUsS0FBQyxLQUFLOzs7Ozs2Q0FGZCxHQUFVLEtBQUMsSUFBSSx3QkFBSyxHQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQWIzQyxHQUFPLElBQUMsUUFBUSxDQUFDLEtBQUs7Ozs7Ozs0QkFF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
