import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, G as onMount, L as globals, l as create_component, m as claim_component, n as mount_component, t as transition_in, k as transition_out, o as destroy_component, H as binding_callbacks, M as bind, N as add_flush_callback, e as element, p as space, a as claim_element, b as children, f as detach_dev, q as claim_space, g as attr_dev, O as toggle_class, h as add_location, x as add_render_callback, j as insert_dev, w as append_dev, P as add_resize_listener, I as group_outros, J as check_outros } from './client.2d8aba47.js';
import { R as Repl } from './Repl.246365e1.js';
import { p as process_example } from './examples.83e383fd.js';
import { I as InputOutputToggle } from './InputOutputToggle.8772f8ec.js';

/* src/components/Repl/ReplWidget.svelte generated by Svelte v3.31.0 */

const { Object: Object_1 } = globals;
const file = "src/components/Repl/ReplWidget.svelte";

// (119:2) {#if true}
function create_if_block_1(ctx) {
	let repl_1;
	let current;

	let repl_1_props = {
		workersUrl: "workers",
		fixed: /*mobile*/ ctx[4],
		svelteUrl: /*svelteUrl*/ ctx[3],
		rollupUrl: /*rollupUrl*/ ctx[5],
		embedded: true,
		relaxed: true
	};

	repl_1 = new Repl({ props: repl_1_props, $$inline: true });
	/*repl_1_binding*/ ctx[11](repl_1);

	const block = {
		c: function create() {
			create_component(repl_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(repl_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(repl_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const repl_1_changes = {};
			if (dirty & /*mobile*/ 16) repl_1_changes.fixed = /*mobile*/ ctx[4];
			if (dirty & /*svelteUrl*/ 8) repl_1_changes.svelteUrl = /*svelteUrl*/ ctx[3];
			repl_1.$set(repl_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(repl_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(repl_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*repl_1_binding*/ ctx[11](null);
			destroy_component(repl_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(119:2) {#if true}",
		ctx
	});

	return block;
}

// (132:1) {#if mobile}
function create_if_block(ctx) {
	let inputoutputtoggle;
	let updating_checked;
	let current;

	function inputoutputtoggle_checked_binding(value) {
		/*inputoutputtoggle_checked_binding*/ ctx[12].call(null, value);
	}

	let inputoutputtoggle_props = {};

	if (/*checked*/ ctx[2] !== void 0) {
		inputoutputtoggle_props.checked = /*checked*/ ctx[2];
	}

	inputoutputtoggle = new InputOutputToggle({
			props: inputoutputtoggle_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(inputoutputtoggle, "checked", inputoutputtoggle_checked_binding));

	const block = {
		c: function create() {
			create_component(inputoutputtoggle.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(inputoutputtoggle.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(inputoutputtoggle, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const inputoutputtoggle_changes = {};

			if (!updating_checked && dirty & /*checked*/ 4) {
				updating_checked = true;
				inputoutputtoggle_changes.checked = /*checked*/ ctx[2];
				add_flush_callback(() => updating_checked = false);
			}

			inputoutputtoggle.$set(inputoutputtoggle_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(inputoutputtoggle.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(inputoutputtoggle.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(inputoutputtoggle, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(132:1) {#if mobile}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let t;
	let div1_resize_listener;
	let current;
	let if_block0 =  create_if_block_1(ctx);
	let if_block1 = /*mobile*/ ctx[4] && create_if_block(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (if_block0) if_block0.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "viewport svelte-247fff");
			toggle_class(div0, "offset", /*checked*/ ctx[2]);
			add_location(div0, file, 117, 1, 2494);
			attr_dev(div1, "class", "repl-outer svelte-247fff");
			add_render_callback(() => /*div1_elementresize_handler*/ ctx[13].call(div1));
			toggle_class(div1, "mobile", /*mobile*/ ctx[4]);
			add_location(div1, file, 116, 0, 2430);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div1, t);
			if (if_block1) if_block1.m(div1, null);
			div1_resize_listener = add_resize_listener(div1, /*div1_elementresize_handler*/ ctx[13].bind(div1));
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if_block0.p(ctx, dirty);

			if (dirty & /*checked*/ 4) {
				toggle_class(div0, "offset", /*checked*/ ctx[2]);
			}

			if (/*mobile*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*mobile*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty & /*mobile*/ 16) {
				toggle_class(div1, "mobile", /*mobile*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			div1_resize_listener();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ReplWidget", slots, []);
	let { version = "3" } = $$props;
	let { gist = null } = $$props;
	let { example = null } = $$props;
	let { embedded = false } = $$props;
	let repl;
	let name = "loading...";
	let width =  window.innerWidth - 32 ;
	let checked = false;

	onMount(() => {
		if (version !== "local") {
			fetch(`https://unpkg.com/svelte@${version}/package.json`).then(r => r.json()).then(pkg => {
				$$invalidate(6, version = pkg.version);
			});
		}

		if (gist) {
			fetch(`repl/${gist}.json`).then(r => r.json()).then(data => {
				const { description, files } = data;
				$$invalidate(10, name = description);

				const components = Object.keys(files).map(file => {
					const dot = file.lastIndexOf(".");
					if (!~dot) return;
					const source = files[file].content;

					return {
						name: file.slice(0, dot),
						type: file.slice(dot + 1),
						source
					};
				}).filter(x => x.type === "svelte" || x.type === "js").sort((a, b) => {
					if (a.name === "App" && a.type === "svelte") return -1;
					if (b.name === "App" && b.type === "svelte") return 1;
					if (a.type !== b.type) return a.type === "svelte" ? -1 : 1;
					return a.name < b.name ? -1 : 1;
				});

				repl.set({ components });
			});
		} else if (example) {
			fetch(`examples/${example}.json`).then(async response => {
				if (response.ok) {
					const data = await response.json();
					repl.set({ components: process_example(data.files) });
				}
			});
		}
	});

	const rollupUrl = `https://unpkg.com/rollup@1/dist/rollup.browser.js`;
	const writable_props = ["version", "gist", "example", "embedded"];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ReplWidget> was created with unknown prop '${key}'`);
	});

	function repl_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			repl = $$value;
			$$invalidate(1, repl);
		});
	}

	function inputoutputtoggle_checked_binding(value) {
		checked = value;
		$$invalidate(2, checked);
	}

	function div1_elementresize_handler() {
		width = this.clientWidth;
		$$invalidate(0, width);
	}

	$$self.$$set = $$props => {
		if ("version" in $$props) $$invalidate(6, version = $$props.version);
		if ("gist" in $$props) $$invalidate(7, gist = $$props.gist);
		if ("example" in $$props) $$invalidate(8, example = $$props.example);
		if ("embedded" in $$props) $$invalidate(9, embedded = $$props.embedded);
	};

	$$self.$capture_state = () => ({
		Repl,
		onMount,
		process_example,
		InputOutputToggle,
		version,
		gist,
		example,
		embedded,
		repl,
		name,
		width,
		checked,
		rollupUrl,
		svelteUrl,
		mobile
	});

	$$self.$inject_state = $$props => {
		if ("version" in $$props) $$invalidate(6, version = $$props.version);
		if ("gist" in $$props) $$invalidate(7, gist = $$props.gist);
		if ("example" in $$props) $$invalidate(8, example = $$props.example);
		if ("embedded" in $$props) $$invalidate(9, embedded = $$props.embedded);
		if ("repl" in $$props) $$invalidate(1, repl = $$props.repl);
		if ("name" in $$props) $$invalidate(10, name = $$props.name);
		if ("width" in $$props) $$invalidate(0, width = $$props.width);
		if ("checked" in $$props) $$invalidate(2, checked = $$props.checked);
		if ("svelteUrl" in $$props) $$invalidate(3, svelteUrl = $$props.svelteUrl);
		if ("mobile" in $$props) $$invalidate(4, mobile = $$props.mobile);
	};

	let svelteUrl;
	let mobile;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*embedded, name*/ 1536) {
			 if (embedded) document.title = `${name} • Svelte REPL`;
		}

		if ($$self.$$.dirty & /*version*/ 64) {
			 $$invalidate(3, svelteUrl =  version === "local"
			? `${location.origin}/repl/local`
			: `https://unpkg.com/svelte@${version}`);
		}

		if ($$self.$$.dirty & /*width*/ 1) {
			 $$invalidate(4, mobile = width < 560);
		}
	};

	return [
		width,
		repl,
		checked,
		svelteUrl,
		mobile,
		rollupUrl,
		version,
		gist,
		example,
		embedded,
		name,
		repl_1_binding,
		inputoutputtoggle_checked_binding,
		div1_elementresize_handler
	];
}

class ReplWidget extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			version: 6,
			gist: 7,
			example: 8,
			embedded: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ReplWidget",
			options,
			id: create_fragment.name
		});
	}

	get version() {
		throw new Error("<ReplWidget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set version(value) {
		throw new Error("<ReplWidget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get gist() {
		throw new Error("<ReplWidget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gist(value) {
		throw new Error("<ReplWidget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get example() {
		throw new Error("<ReplWidget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set example(value) {
		throw new Error("<ReplWidget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get embedded() {
		throw new Error("<ReplWidget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set embedded(value) {
		throw new Error("<ReplWidget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { ReplWidget as R };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVwbFdpZGdldC44ODMzODFhMi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvUmVwbC9SZXBsV2lkZ2V0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuXHRpbXBvcnQgUmVwbCBmcm9tICdAc3ZlbHRlanMvc3ZlbHRlLXJlcGwnO1xuXHRpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcblxuXHRpbXBvcnQgeyBwcm9jZXNzX2V4YW1wbGUgfSBmcm9tICcuLi8uLi91dGlscy9leGFtcGxlcyc7XG5cdGltcG9ydCBJbnB1dE91dHB1dFRvZ2dsZSBmcm9tICcuL0lucHV0T3V0cHV0VG9nZ2xlLnN2ZWx0ZSc7XG5cblx0ZXhwb3J0IGxldCB2ZXJzaW9uID0gJzMnO1xuXHRleHBvcnQgbGV0IGdpc3QgPSBudWxsO1xuXHRleHBvcnQgbGV0IGV4YW1wbGUgPSBudWxsO1xuXHRleHBvcnQgbGV0IGVtYmVkZGVkID0gZmFsc2U7XG5cblx0bGV0IHJlcGw7XG5cdGxldCBuYW1lID0gJ2xvYWRpbmcuLi4nO1xuXHRsZXQgd2lkdGggPSBwcm9jZXNzLmJyb3dzZXJcblx0XHQ/IHdpbmRvdy5pbm5lcldpZHRoIC0gMzJcblx0XHQ6IDEwMDA7XG5cblx0bGV0IGNoZWNrZWQgPSBmYWxzZTtcblxuXHRvbk1vdW50KCgpID0+IHtcblx0XHRpZiAodmVyc2lvbiAhPT0gJ2xvY2FsJykge1xuXHRcdFx0ZmV0Y2goYGh0dHBzOi8vdW5wa2cuY29tL3N2ZWx0ZUAke3ZlcnNpb259L3BhY2thZ2UuanNvbmApXG5cdFx0XHRcdC50aGVuKHIgPT4gci5qc29uKCkpXG5cdFx0XHRcdC50aGVuKHBrZyA9PiB7XG5cdFx0XHRcdFx0dmVyc2lvbiA9IHBrZy52ZXJzaW9uO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoZ2lzdCkge1xuXHRcdFx0ZmV0Y2goYHJlcGwvJHtnaXN0fS5qc29uYCkudGhlbihyID0+IHIuanNvbigpKS50aGVuKGRhdGEgPT4ge1xuXHRcdFx0XHRjb25zdCB7IGRlc2NyaXB0aW9uLCBmaWxlcyB9ID0gZGF0YTtcblxuXHRcdFx0XHRuYW1lID0gZGVzY3JpcHRpb247XG5cblx0XHRcdFx0Y29uc3QgY29tcG9uZW50cyA9IE9iamVjdC5rZXlzKGZpbGVzKVxuXHRcdFx0XHRcdC5tYXAoZmlsZSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBkb3QgPSBmaWxlLmxhc3RJbmRleE9mKCcuJyk7XG5cdFx0XHRcdFx0XHRpZiAoIX5kb3QpIHJldHVybjtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgc291cmNlID0gZmlsZXNbZmlsZV0uY29udGVudDtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0bmFtZTogZmlsZS5zbGljZSgwLCBkb3QpLFxuXHRcdFx0XHRcdFx0XHR0eXBlOiBmaWxlLnNsaWNlKGRvdCArIDEpLFxuXHRcdFx0XHRcdFx0XHRzb3VyY2Vcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuZmlsdGVyKHggPT4geC50eXBlID09PSAnc3ZlbHRlJyB8fCB4LnR5cGUgPT09ICdqcycpXG5cdFx0XHRcdFx0LnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdFx0XHRcdGlmIChhLm5hbWUgPT09ICdBcHAnICYmIGEudHlwZSA9PT0gJ3N2ZWx0ZScpIHJldHVybiAtMTtcblx0XHRcdFx0XHRcdGlmIChiLm5hbWUgPT09ICdBcHAnICYmIGIudHlwZSA9PT0gJ3N2ZWx0ZScpIHJldHVybiAxO1xuXG5cdFx0XHRcdFx0XHRpZiAoYS50eXBlICE9PSBiLnR5cGUpIHJldHVybiBhLnR5cGUgPT09ICdzdmVsdGUnID8gLTEgOiAxO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gYS5uYW1lIDwgYi5uYW1lID8gLTEgOiAxO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJlcGwuc2V0KHsgY29tcG9uZW50cyB9KTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoZXhhbXBsZSkge1xuXHRcdFx0ZmV0Y2goYGV4YW1wbGVzLyR7ZXhhbXBsZX0uanNvbmApLnRoZW4oYXN5bmMgcmVzcG9uc2UgPT4ge1xuXHRcdFx0XHRpZiAocmVzcG9uc2Uub2spIHtcblx0XHRcdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG5cdFx0XHRcdFx0cmVwbC5zZXQoe1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50czogcHJvY2Vzc19leGFtcGxlKGRhdGEuZmlsZXMpXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0JDogaWYgKGVtYmVkZGVkKSBkb2N1bWVudC50aXRsZSA9IGAke25hbWV9IOKAoiBTdmVsdGUgUkVQTGA7XG5cblx0JDogc3ZlbHRlVXJsID0gcHJvY2Vzcy5icm93c2VyICYmIHZlcnNpb24gPT09ICdsb2NhbCcgP1xuXHRcdGAke2xvY2F0aW9uLm9yaWdpbn0vcmVwbC9sb2NhbGAgOlxuXHRcdGBodHRwczovL3VucGtnLmNvbS9zdmVsdGVAJHt2ZXJzaW9ufWA7XG5cblx0Y29uc3Qgcm9sbHVwVXJsID0gYGh0dHBzOi8vdW5wa2cuY29tL3JvbGx1cEAxL2Rpc3Qvcm9sbHVwLmJyb3dzZXIuanNgO1xuXG5cdCQ6IG1vYmlsZSA9IHdpZHRoIDwgNTYwO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0LnJlcGwtb3V0ZXIge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJhY2spO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHQtLXBhbmUtY29udHJvbHMtaDogNC4ycmVtO1xuXHR9XG5cblx0LnZpZXdwb3J0IHtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0ZmxleDogMTtcblx0fVxuXG5cdC5tb2JpbGUgLnZpZXdwb3J0IHtcblx0XHR3aWR0aDogMjAwJTtcblx0XHRoZWlnaHQ6IGNhbGMoMTAwJSAtIDQycHgpO1xuXHRcdHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjNzO1xuXHR9XG5cblx0Lm1vYmlsZSAub2Zmc2V0IHtcblx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAwKTtcblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cInJlcGwtb3V0ZXJcIiBiaW5kOmNsaWVudFdpZHRoPXt3aWR0aH0gY2xhc3M6bW9iaWxlPlxuXHQ8ZGl2IGNsYXNzPVwidmlld3BvcnRcIiBjbGFzczpvZmZzZXQ9e2NoZWNrZWR9PlxuXHRcdHsjaWYgcHJvY2Vzcy5icm93c2VyfVxuXHRcdFx0PFJlcGxcblx0XHRcdFx0YmluZDp0aGlzPXtyZXBsfVxuXHRcdFx0XHR3b3JrZXJzVXJsPVwid29ya2Vyc1wiXG5cdFx0XHRcdGZpeGVkPXttb2JpbGV9XG5cdFx0XHRcdHtzdmVsdGVVcmx9XG5cdFx0XHRcdHtyb2xsdXBVcmx9XG5cdFx0XHRcdGVtYmVkZGVkXG5cdFx0XHRcdHJlbGF4ZWRcblx0XHRcdC8+XG5cdFx0ey9pZn1cblx0PC9kaXY+XG5cblx0eyNpZiBtb2JpbGV9XG5cdFx0PElucHV0T3V0cHV0VG9nZ2xlIGJpbmQ6Y2hlY2tlZC8+XG5cdHsvaWZ9XG48L2Rpdj5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztvQkEwSFcsR0FBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0VBQU4sR0FBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBU1gsR0FBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
