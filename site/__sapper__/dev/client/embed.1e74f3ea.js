import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, l as create_component, m as claim_component, n as mount_component, t as transition_in, k as transition_out, o as destroy_component, e as element, p as space, K as query_selector_all, a as claim_element, f as detach_dev, q as claim_space, b as children, g as attr_dev, h as add_location, w as append_dev, j as insert_dev } from './client.2d8aba47.js';
import './Repl.246365e1.js';
import './examples.83e383fd.js';
import './InputOutputToggle.8772f8ec.js';
import { R as ReplWidget } from './ReplWidget.883381a2.js';

/* src/routes/repl/embed.svelte generated by Svelte v3.31.0 */
const file = "src/routes/repl/embed.svelte";

// (44:1) {#if true}
function create_if_block(ctx) {
	let replwidget;
	let current;

	replwidget = new ReplWidget({
			props: {
				version: /*version*/ ctx[0],
				gist: /*gist*/ ctx[1],
				example: /*example*/ ctx[2],
				embedded: true
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(replwidget.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(replwidget.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(replwidget, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const replwidget_changes = {};
			if (dirty & /*version*/ 1) replwidget_changes.version = /*version*/ ctx[0];
			if (dirty & /*gist*/ 2) replwidget_changes.gist = /*gist*/ ctx[1];
			if (dirty & /*example*/ 4) replwidget_changes.example = /*example*/ ctx[2];
			replwidget.$set(replwidget_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(replwidget.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(replwidget.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(replwidget, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(44:1) {#if true}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let meta0;
	let meta1;
	let meta2;
	let t;
	let div;
	let current;
	let if_block =  create_if_block(ctx);

	const block = {
		c: function create() {
			meta0 = element("meta");
			meta1 = element("meta");
			meta2 = element("meta");
			t = space();
			div = element("div");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-12ufkeu\"]", document.head);
			meta0 = claim_element(head_nodes, "META", { name: true, content: true });
			meta1 = claim_element(head_nodes, "META", { name: true, content: true });
			meta2 = claim_element(head_nodes, "META", { name: true, content: true });
			head_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "REPL â€¢ Svelte";
			attr_dev(meta0, "name", "twitter:title");
			attr_dev(meta0, "content", "Svelte REPL");
			add_location(meta0, file, 37, 1, 626);
			attr_dev(meta1, "name", "twitter:description");
			attr_dev(meta1, "content", "Cybernetically enhanced web apps");
			add_location(meta1, file, 38, 1, 677);
			attr_dev(meta2, "name", "Description");
			attr_dev(meta2, "content", "Interactive Svelte playground");
			add_location(meta2, file, 39, 1, 755);
			attr_dev(div, "class", "repl-outer svelte-icca0y");
			add_location(div, file, 42, 0, 837);
		},
		m: function mount(target, anchor) {
			append_dev(document.head, meta0);
			append_dev(document.head, meta1);
			append_dev(document.head, meta2);
			insert_dev(target, t, anchor);
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			detach_dev(meta0);
			detach_dev(meta1);
			detach_dev(meta2);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function preload({ query }) {
	return {
		version: query.version,
		gist: query.gist,
		example: query.example
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Embed", slots, []);
	let { version = "3" } = $$props;
	let { gist } = $$props;
	let { example } = $$props;
	const writable_props = ["version", "gist", "example"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Embed> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("version" in $$props) $$invalidate(0, version = $$props.version);
		if ("gist" in $$props) $$invalidate(1, gist = $$props.gist);
		if ("example" in $$props) $$invalidate(2, example = $$props.example);
	};

	$$self.$capture_state = () => ({
		preload,
		ReplWidget,
		version,
		gist,
		example
	});

	$$self.$inject_state = $$props => {
		if ("version" in $$props) $$invalidate(0, version = $$props.version);
		if ("gist" in $$props) $$invalidate(1, gist = $$props.gist);
		if ("example" in $$props) $$invalidate(2, example = $$props.example);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [version, gist, example];
}

class Embed extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { version: 0, gist: 1, example: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Embed",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*gist*/ ctx[1] === undefined && !("gist" in props)) {
			console.warn("<Embed> was created without expected prop 'gist'");
		}

		if (/*example*/ ctx[2] === undefined && !("example" in props)) {
			console.warn("<Embed> was created without expected prop 'example'");
		}
	}

	get version() {
		throw new Error("<Embed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set version(value) {
		throw new Error("<Embed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get gist() {
		throw new Error("<Embed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gist(value) {
		throw new Error("<Embed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get example() {
		throw new Error("<Embed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set example(value) {
		throw new Error("<Embed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Embed;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1iZWQuMWU3NGYzZWEuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvcmVwbC9lbWJlZC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG5cdGV4cG9ydCBmdW5jdGlvbiBwcmVsb2FkKHsgcXVlcnkgfSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR2ZXJzaW9uOiBxdWVyeS52ZXJzaW9uLFxuXHRcdFx0Z2lzdDogcXVlcnkuZ2lzdCxcblx0XHRcdGV4YW1wbGU6IHF1ZXJ5LmV4YW1wbGVcblx0XHR9O1xuXHR9XG48L3NjcmlwdD5cblxuPHNjcmlwdD5cblx0aW1wb3J0IFJlcGxXaWRnZXQgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9SZXBsL1JlcGxXaWRnZXQuc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IHZlcnNpb24gPSAnMyc7XG5cdGV4cG9ydCBsZXQgZ2lzdDtcblx0ZXhwb3J0IGxldCBleGFtcGxlO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0LnJlcGwtb3V0ZXIge1xuXHRcdHBvc2l0aW9uOiBmaXhlZDtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYmFjayk7XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdC0tcGFuZS1jb250cm9scy1oOiA0LjJyZW07XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHR9XG48L3N0eWxlPlxuXG48c3ZlbHRlOmhlYWQ+XG5cdDx0aXRsZT5SRVBMIOKAoiBTdmVsdGU8L3RpdGxlPlxuXG5cdDxtZXRhIG5hbWU9XCJ0d2l0dGVyOnRpdGxlXCIgY29udGVudD1cIlN2ZWx0ZSBSRVBMXCI+XG5cdDxtZXRhIG5hbWU9XCJ0d2l0dGVyOmRlc2NyaXB0aW9uXCIgY29udGVudD1cIkN5YmVybmV0aWNhbGx5IGVuaGFuY2VkIHdlYiBhcHBzXCI+XG5cdDxtZXRhIG5hbWU9XCJEZXNjcmlwdGlvblwiIGNvbnRlbnQ9XCJJbnRlcmFjdGl2ZSBTdmVsdGUgcGxheWdyb3VuZFwiPlxuPC9zdmVsdGU6aGVhZD5cblxuPGRpdiBjbGFzcz1cInJlcGwtb3V0ZXJcIj5cblx0eyNpZiBwcm9jZXNzLmJyb3dzZXJ9XG5cdFx0PFJlcGxXaWRnZXQge3ZlcnNpb259IHtnaXN0fSB7ZXhhbXBsZX0gZW1iZWRkZWQ9e3RydWV9Lz5cblx0ey9pZn1cbjwvZGl2PlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Y0E0Q21ELElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0EzQ3RDLE9BQU8sR0FBRyxLQUFLOztFQUU3QixPQUFPLEVBQUUsS0FBSyxDQUFDLE9BQU87RUFDdEIsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJO0VBQ2hCLE9BQU8sRUFBRSxLQUFLLENBQUMsT0FBTzs7Ozs7OztPQVFiLE9BQU8sR0FBRyxHQUFHO09BQ2IsSUFBSTtPQUNKLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9
