import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, af as stores$1, V as validate_store, X as component_subscribe, U as getContext, e as element, A as text, p as space, a as claim_element, b as children, B as claim_text, f as detach_dev, q as claim_space, g as attr_dev, h as add_location, j as insert_dev, w as append_dev, y as listen_dev, z as noop, C as set_data_dev, T as run_all, L as globals, aa as Icon, Q as createEventDispatcher, l as create_component, m as claim_component, r as set_style, _ as set_input_value, n as mount_component, R as action_destroyer, I as group_outros, k as transition_out, J as check_outros, t as transition_in, a1 as prop_dev, o as destroy_component, ad as prevent_default, x as add_render_callback, G as onMount, a9 as goto, E as empty, O as toggle_class, H as binding_callbacks, M as bind, N as add_flush_callback, K as query_selector_all } from './client.2d8aba47.js';
import { R as Repl } from './Repl.246365e1.js';
import { I as InputOutputToggle } from './InputOutputToggle.8772f8ec.js';

/* src/routes/repl/[id]/_components/AppControls/UserMenu.svelte generated by Svelte v3.31.0 */
const file = "src/routes/repl/[id]/_components/AppControls/UserMenu.svelte";

// (18:1) {#if showMenu}
function create_if_block(ctx) {
	let div;
	let a;
	let t0;
	let t1;
	let button;
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			a = element("a");
			t0 = text("Your saved apps");
			t1 = space();
			button = element("button");
			t2 = text("Log out");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			a = claim_element(div_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, "Your saved apps");
			a_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			button = claim_element(div_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t2 = claim_text(button_nodes, "Log out");
			button_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", "apps");
			attr_dev(a, "class", "svelte-1jk26jo");
			add_location(a, file, 19, 3, 479);
			attr_dev(button, "class", "svelte-1jk26jo");
			add_location(button, file, 20, 3, 517);
			attr_dev(div, "class", "menu svelte-1jk26jo");
			add_location(div, file, 18, 2, 457);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, a);
			append_dev(a, t0);
			append_dev(div, t1);
			append_dev(div, button);
			append_dev(button, t2);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*logout*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(18:1) {#if showMenu}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div;
	let span;
	let t0;
	let t1;
	let img;
	let img_alt_value;
	let img_src_value;
	let t2;
	let mounted;
	let dispose;
	let if_block = /*showMenu*/ ctx[1] && create_if_block(ctx);

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			t0 = text(/*name*/ ctx[2]);
			t1 = space();
			img = element("img");
			t2 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, /*name*/ ctx[2]);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			img = claim_element(div_nodes, "IMG", { alt: true, src: true, class: true });
			t2 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "svelte-1jk26jo");
			add_location(span, file, 14, 1, 362);
			attr_dev(img, "alt", img_alt_value = "" + (/*name*/ ctx[2] + " avatar"));
			if (img.src !== (img_src_value = /*$session*/ ctx[0].user.avatar)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "class", "svelte-1jk26jo");
			add_location(img, file, 15, 1, 383);
			attr_dev(div, "class", "user svelte-1jk26jo");
			add_location(div, file, 13, 0, 261);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			append_dev(span, t0);
			append_dev(div, t1);
			append_dev(div, img);
			append_dev(div, t2);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = [
					listen_dev(div, "mouseenter", /*mouseenter_handler*/ ctx[5], false, false, false),
					listen_dev(div, "mouseleave", /*mouseleave_handler*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*name*/ 4) set_data_dev(t0, /*name*/ ctx[2]);

			if (dirty & /*name*/ 4 && img_alt_value !== (img_alt_value = "" + (/*name*/ ctx[2] + " avatar"))) {
				attr_dev(img, "alt", img_alt_value);
			}

			if (dirty & /*$session*/ 1 && img.src !== (img_src_value = /*$session*/ ctx[0].user.avatar)) {
				attr_dev(img, "src", img_src_value);
			}

			if (/*showMenu*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $session;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("UserMenu", slots, []);
	const { session } = stores$1();
	validate_store(session, "session");
	component_subscribe($$self, session, value => $$invalidate(0, $session = value));
	const { logout } = getContext("app");
	let showMenu = false;
	let name;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UserMenu> was created with unknown prop '${key}'`);
	});

	const mouseenter_handler = () => $$invalidate(1, showMenu = true);
	const mouseleave_handler = () => $$invalidate(1, showMenu = false);

	$$self.$capture_state = () => ({
		getContext,
		stores: stores$1,
		session,
		logout,
		showMenu,
		name,
		$session
	});

	$$self.$inject_state = $$props => {
		if ("showMenu" in $$props) $$invalidate(1, showMenu = $$props.showMenu);
		if ("name" in $$props) $$invalidate(2, name = $$props.name);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$session*/ 1) {
			 $$invalidate(2, name = $session.user.name || $session.user.username);
		}
	};

	return [
		$session,
		showMenu,
		name,
		session,
		logout,
		mouseenter_handler,
		mouseleave_handler
	];
}

class UserMenu extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UserMenu",
			options,
			id: create_fragment.name
		});
	}
}

const table = [];
for (let n = 0; n < 256; n++) {
	let c = n;
	for (let k = 0; k < 8; k++) {
		c = c & 1 ? 0xEDB88320 ^ (c >>> 1) : c >>> 1;
	}
	table[n] = c;
}

var crc32 = bytes => {
	let sum = -1;
	for (const byte of bytes) {
		sum = (sum >>> 8) ^ table[(sum ^ byte) & 0xFF];
	}
	return sum ^ -1;
};

const int = (n, length) => {
	const out = [];
	while (length--) {
		out.push(n & 0xFF);
		n >>>= 8;
	}
	return out;
};

const toBytes = data => typeof data === 'string' ? [...data].map(char => char.charCodeAt(0)) : data;

var toArray = files => {
	let fileData = [];
	const centralDirectory = [];
	for (const { path, data } of files) {
		const dataBytes = toBytes(data);
		const pathBytes = toBytes(path);
		const commonHeader = [0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ...int(crc32(dataBytes), 4), ...int(dataBytes.length, 4), ...int(dataBytes.length, 4), ...int(pathBytes.length, 2), 0x00, 0x00];
		centralDirectory.push(0x50, 0x4B, 0x01, 0x02, 0x14, 0x00, ...commonHeader, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ...int(fileData.length, 4), ...pathBytes);
		fileData = [...fileData, 0x50, 0x4B, 0x03, 0x04, ...commonHeader, ...pathBytes, ...dataBytes];
	}
	return [...fileData, ...centralDirectory, 0x50, 0x4B, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, ...int(files.length, 2), ...int(files.length, 2), ...int(centralDirectory.length, 4), ...int(fileData.length, 4), 0x00, 0x00];
};

var toBlob = files => new Blob([Uint8Array.from(toArray(files))], { type: 'application/zip' });

var toBuffer = files => Buffer.from(toArray(files));

var toAuto = files => (typeof Blob === 'undefined' ? toBuffer : toBlob)(files);

var doNotZip = /*#__PURE__*/Object.freeze({
	__proto__: null,
	toArray: toArray,
	toAuto: toAuto,
	toBlob: toBlob,
	toBuffer: toBuffer
});

var downloadBlob = (blob, filename) => {
	const url = URL.createObjectURL(blob);
	const link = document.createElement('a');
	link.href = url;
	link.download = filename;
	link.style.display = 'none';
	document.body.appendChild(link);
	link.click();
	URL.revokeObjectURL(url);
	link.remove();
};

function keyEvent(code) {
	return function (node, callback) {
		node.addEventListener('keydown', handleKeydown);

		function handleKeydown(event) {
			if (event.keyCode === code) {
				callback.call(this, event);
			}
		}

		return {
			destroy() {
				node.removeEventListener('keydown', handleKeydown);
			}
		};
	};
}

const enter = keyEvent(13);

const isMac = typeof navigator !== 'undefined' && navigator.platform === 'MacIntel';

/* src/routes/repl/[id]/_components/AppControls/index.svelte generated by Svelte v3.31.0 */

const { Error: Error_1 } = globals;
const file$1 = "src/routes/repl/[id]/_components/AppControls/index.svelte";

// (181:3) {:else}
function create_else_block_3(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: { name: "maximize" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_3.name,
		type: "else",
		source: "(181:3) {:else}",
		ctx
	});

	return block;
}

// (179:3) {#if zen_mode}
function create_if_block_3(ctx) {
	let icon;
	let current;
	icon = new Icon({ props: { name: "close" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(179:3) {#if zen_mode}",
		ctx
	});

	return block;
}

// (193:3) {:else}
function create_else_block_2(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: { name: "git-branch" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(193:3) {:else}",
		ctx
	});

	return block;
}

// (191:3) {#if justForked}
function create_if_block_2(ctx) {
	let icon;
	let current;
	icon = new Icon({ props: { name: "check" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(191:3) {#if justForked}",
		ctx
	});

	return block;
}

// (201:3) {:else}
function create_else_block_1(ctx) {
	let icon;
	let current;
	icon = new Icon({ props: { name: "save" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(201:3) {:else}",
		ctx
	});

	return block;
}

// (199:3) {#if justSaved}
function create_if_block_1(ctx) {
	let icon;
	let current;
	icon = new Icon({ props: { name: "check" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(199:3) {#if justSaved}",
		ctx
	});

	return block;
}

// (208:2) {:else}
function create_else_block(ctx) {
	let button;
	let icon;
	let t0;
	let span;
	let t1;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: { name: "log-in" },
			$$inline: true
		});

	const block = {
		c: function create() {
			button = element("button");
			create_component(icon.$$.fragment);
			t0 = space();
			span = element("span");
			t1 = text(" Log in to save");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			claim_component(icon.$$.fragment, button_nodes);
			t0 = claim_space(button_nodes);
			span = claim_element(button_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t1 = claim_text(span_nodes, " Log in to save");
			span_nodes.forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "svelte-1xhvee5");
			add_location(span, file$1, 210, 4, 5014);
			attr_dev(button, "class", "icon svelte-1xhvee5");
			add_location(button, file$1, 208, 3, 4929);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			mount_component(icon, button, null);
			append_dev(button, t0);
			append_dev(button, span);
			append_dev(span, t1);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", prevent_default(/*login*/ ctx[8]), false, true, false);
				mounted = true;
			}
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			destroy_component(icon);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(208:2) {:else}",
		ctx
	});

	return block;
}

// (206:2) {#if $session.user}
function create_if_block$1(ctx) {
	let usermenu;
	let current;
	usermenu = new UserMenu({ $$inline: true });

	const block = {
		c: function create() {
			create_component(usermenu.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(usermenu.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(usermenu, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(usermenu.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(usermenu.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(usermenu, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(206:2) {#if $session.user}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div1;
	let input;
	let enter_action;
	let t0;
	let div0;
	let button0;
	let current_block_type_index;
	let if_block0;
	let t1;
	let button1;
	let icon;
	let t2;
	let button2;
	let current_block_type_index_1;
	let if_block1;
	let button2_disabled_value;
	let t3;
	let button3;
	let current_block_type_index_2;
	let if_block2;
	let button3_disabled_value;
	let t4;
	let current_block_type_index_3;
	let if_block3;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_3, create_else_block_3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*zen_mode*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	icon = new Icon({
			props: { name: "download" },
			$$inline: true
		});

	const if_block_creators_1 = [create_if_block_2, create_else_block_2];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*justForked*/ ctx[6]) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
	const if_block_creators_2 = [create_if_block_1, create_else_block_1];
	const if_blocks_2 = [];

	function select_block_type_2(ctx, dirty) {
		if (/*justSaved*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index_2 = select_block_type_2(ctx);
	if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
	const if_block_creators_3 = [create_if_block$1, create_else_block];
	const if_blocks_3 = [];

	function select_block_type_3(ctx, dirty) {
		if (/*$session*/ ctx[2].user) return 0;
		return 1;
	}

	current_block_type_index_3 = select_block_type_3(ctx);
	if_block3 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			input = element("input");
			t0 = space();
			div0 = element("div");
			button0 = element("button");
			if_block0.c();
			t1 = space();
			button1 = element("button");
			create_component(icon.$$.fragment);
			t2 = space();
			button2 = element("button");
			if_block1.c();
			t3 = space();
			button3 = element("button");
			if_block2.c();
			t4 = space();
			if_block3.c();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			input = claim_element(div1_nodes, "INPUT", { class: true });
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			button0 = claim_element(div0_nodes, "BUTTON", { class: true, title: true });
			var button0_nodes = children(button0);
			if_block0.l(button0_nodes);
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);
			button1 = claim_element(div0_nodes, "BUTTON", { class: true, disabled: true, title: true });
			var button1_nodes = children(button1);
			claim_component(icon.$$.fragment, button1_nodes);
			button1_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);
			button2 = claim_element(div0_nodes, "BUTTON", { class: true, disabled: true, title: true });
			var button2_nodes = children(button2);
			if_block1.l(button2_nodes);
			button2_nodes.forEach(detach_dev);
			t3 = claim_space(div0_nodes);
			button3 = claim_element(div0_nodes, "BUTTON", { class: true, disabled: true, title: true });
			var button3_nodes = children(button3);
			if_block2.l(button3_nodes);
			button3_nodes.forEach(detach_dev);
			t4 = claim_space(div0_nodes);
			if_block3.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "class", "svelte-1xhvee5");
			add_location(input, file$1, 170, 1, 3982);
			attr_dev(button0, "class", "icon svelte-1xhvee5");
			attr_dev(button0, "title", "fullscreen editor");
			add_location(button0, file$1, 177, 2, 4143);
			attr_dev(button1, "class", "icon svelte-1xhvee5");
			button1.disabled = /*downloading*/ ctx[4];
			attr_dev(button1, "title", "download zip file");
			add_location(button1, file$1, 185, 2, 4339);
			attr_dev(button2, "class", "icon svelte-1xhvee5");
			button2.disabled = button2_disabled_value = /*saving*/ ctx[3] || !/*$session*/ ctx[2].user;
			attr_dev(button2, "title", "fork");
			add_location(button2, file$1, 189, 2, 4473);
			attr_dev(button3, "class", "icon svelte-1xhvee5");
			button3.disabled = button3_disabled_value = /*saving*/ ctx[3] || !/*$session*/ ctx[2].user;
			attr_dev(button3, "title", "save");
			add_location(button3, file$1, 197, 2, 4687);
			set_style(div0, "text-align", "right");
			set_style(div0, "margin-right", ".4rem");
			add_location(div0, file$1, 176, 1, 4089);
			attr_dev(div1, "class", "app-controls svelte-1xhvee5");
			add_location(div1, file$1, 169, 0, 3954);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, input);
			set_input_value(input, /*name*/ ctx[0]);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, button0);
			if_blocks[current_block_type_index].m(button0, null);
			append_dev(div0, t1);
			append_dev(div0, button1);
			mount_component(icon, button1, null);
			append_dev(div0, t2);
			append_dev(div0, button2);
			if_blocks_1[current_block_type_index_1].m(button2, null);
			append_dev(div0, t3);
			append_dev(div0, button3);
			if_blocks_2[current_block_type_index_2].m(button3, null);
			append_dev(div0, t4);
			if_blocks_3[current_block_type_index_3].m(div0, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window, "keydown", /*handleKeydown*/ ctx[9], false, false, false),
					listen_dev(input, "input", /*input_input_handler*/ ctx[16]),
					listen_dev(input, "focus", focus_handler, false, false, false),
					action_destroyer(enter_action = enter.call(null, input, enter_function)),
					listen_dev(button0, "click", /*click_handler*/ ctx[17], false, false, false),
					listen_dev(button1, "click", /*download*/ ctx[12], false, false, false),
					listen_dev(button2, "click", /*click_handler_1*/ ctx[18], false, false, false),
					listen_dev(button3, "click", /*save*/ ctx[11], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*name*/ 1 && input.value !== /*name*/ ctx[0]) {
				set_input_value(input, /*name*/ ctx[0]);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(button0, null);
			}

			if (!current || dirty & /*downloading*/ 16) {
				prop_dev(button1, "disabled", /*downloading*/ ctx[4]);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 !== previous_block_index_1) {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block1 = if_blocks_1[current_block_type_index_1];

				if (!if_block1) {
					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in(if_block1, 1);
				if_block1.m(button2, null);
			}

			if (!current || dirty & /*saving, $session*/ 12 && button2_disabled_value !== (button2_disabled_value = /*saving*/ ctx[3] || !/*$session*/ ctx[2].user)) {
				prop_dev(button2, "disabled", button2_disabled_value);
			}

			let previous_block_index_2 = current_block_type_index_2;
			current_block_type_index_2 = select_block_type_2(ctx);

			if (current_block_type_index_2 !== previous_block_index_2) {
				group_outros();

				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
					if_blocks_2[previous_block_index_2] = null;
				});

				check_outros();
				if_block2 = if_blocks_2[current_block_type_index_2];

				if (!if_block2) {
					if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(button3, null);
			}

			if (!current || dirty & /*saving, $session*/ 12 && button3_disabled_value !== (button3_disabled_value = /*saving*/ ctx[3] || !/*$session*/ ctx[2].user)) {
				prop_dev(button3, "disabled", button3_disabled_value);
			}

			let previous_block_index_3 = current_block_type_index_3;
			current_block_type_index_3 = select_block_type_3(ctx);

			if (current_block_type_index_3 === previous_block_index_3) {
				if_blocks_3[current_block_type_index_3].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
					if_blocks_3[previous_block_index_3] = null;
				});

				check_outros();
				if_block3 = if_blocks_3[current_block_type_index_3];

				if (!if_block3) {
					if_block3 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
					if_block3.c();
				} else {
					if_block3.p(ctx, dirty);
				}

				transition_in(if_block3, 1);
				if_block3.m(div0, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(icon.$$.fragment, local);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(icon.$$.fragment, local);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if_blocks[current_block_type_index].d();
			destroy_component(icon);
			if_blocks_1[current_block_type_index_1].d();
			if_blocks_2[current_block_type_index_2].d();
			if_blocks_3[current_block_type_index_3].d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function wait(ms) {
	return new Promise(f => setTimeout(f, ms));
}

const focus_handler = e => e.target.select();
const enter_function = e => e.target.blur();

function instance$1($$self, $$props, $$invalidate) {
	let $session;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("AppControls", slots, []);
	const dispatch = createEventDispatcher();
	const { session } = stores$1();
	validate_store(session, "session");
	component_subscribe($$self, session, value => $$invalidate(2, $session = value));
	const { login } = getContext("app");
	let { repl } = $$props;
	let { gist } = $$props;
	let { name } = $$props;
	let { zen_mode } = $$props;
	let { bundle } = $$props;
	let saving = false;
	let downloading = false;
	let justSaved = false;
	let justForked = false;

	function handleKeydown(event) {
		if (event.key === "s" && (isMac ? event.metaKey : event.ctrlKey)) {
			event.preventDefault();
			save();
		}
	}

	async function fork(intentWasSave) {
		$$invalidate(3, saving = true);
		const { components } = repl.toJSON();

		try {
			const r = await fetch(`repl/create.json`, {
				method: "POST",
				credentials: "include",
				body: JSON.stringify({
					name,
					files: components.map(component => ({
						name: `${component.name}.${component.type}`,
						source: component.source
					}))
				})
			});

			if (r.status < 200 || r.status >= 300) {
				const { error } = await r.json();
				throw new Error(`Received an HTTP ${r.status} response: ${error}`);
			}

			const gist = await r.json();
			dispatch("forked", { gist });

			if (intentWasSave) {
				$$invalidate(5, justSaved = true);
				await wait(600);
				$$invalidate(5, justSaved = false);
			} else {
				$$invalidate(6, justForked = true);
				await wait(600);
				$$invalidate(6, justForked = false);
			}
		} catch(err) {
			if (navigator.onLine) {
				alert(err.message);
			} else {
				alert(`It looks like you're offline! Find the internet and try again`);
			}
		}

		$$invalidate(3, saving = false);
	}

	async function save() {
		if (saving) return;

		if (!canSave) {
			fork(true);
			return;
		}

		$$invalidate(3, saving = true);

		try {
			// Send all files back to API
			// ~> Any missing files are considered deleted!
			const { components } = repl.toJSON();

			const r = await fetch(`repl/${gist.uid}.json`, {
				method: "PATCH",
				credentials: "include",
				body: JSON.stringify({
					name,
					files: components.map(component => ({
						name: `${component.name}.${component.type}`,
						source: component.source
					}))
				})
			});

			if (r.status < 200 || r.status >= 300) {
				const { error } = await r.json();
				throw new Error(`Received an HTTP ${r.status} response: ${error}`);
			}

			await r.json();
			$$invalidate(5, justSaved = true);
			await wait(600);
			$$invalidate(5, justSaved = false);
		} catch(err) {
			if (navigator.onLine) {
				alert(err.message);
			} else {
				alert(`It looks like you're offline! Find the internet and try again`);
			}
		}

		$$invalidate(3, saving = false);
	}

	async function download() {
		$$invalidate(4, downloading = true);
		const { components, imports } = repl.toJSON();
		const files = await (await fetch("/svelte-app.json")).json();

		if (imports.length > 0) {
			const idx = files.findIndex(({ path }) => path === "package.json");
			const pkg = JSON.parse(files[idx].data);
			const { devDependencies } = pkg;

			imports.forEach(mod => {
				const match = (/^(@[^/]+\/)?[^@/]+/).exec(mod);
				devDependencies[match[0]] = "latest";
			});

			pkg.devDependencies = devDependencies;
			files[idx].data = JSON.stringify(pkg, null, "  ");
		}

		files.push(...components.map(component => ({
			path: `src/${component.name}.${component.type}`,
			data: component.source
		})));

		files.push({
			path: `src/main.js`,
			data: `import App from './App.svelte';

var app = new App({
	target: document.body
});

export default app;`
		});

		downloadBlob(toBlob(files), "svelte-app.zip");
		$$invalidate(4, downloading = false);
	}

	const writable_props = ["repl", "gist", "name", "zen_mode", "bundle"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AppControls> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		name = this.value;
		$$invalidate(0, name);
	}

	const click_handler = () => $$invalidate(1, zen_mode = !zen_mode);
	const click_handler_1 = () => fork(false);

	$$self.$$set = $$props => {
		if ("repl" in $$props) $$invalidate(13, repl = $$props.repl);
		if ("gist" in $$props) $$invalidate(14, gist = $$props.gist);
		if ("name" in $$props) $$invalidate(0, name = $$props.name);
		if ("zen_mode" in $$props) $$invalidate(1, zen_mode = $$props.zen_mode);
		if ("bundle" in $$props) $$invalidate(15, bundle = $$props.bundle);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		getContext,
		stores: stores$1,
		UserMenu,
		Icon,
		doNotZip,
		downloadBlob,
		enter,
		isMac,
		dispatch,
		session,
		login,
		repl,
		gist,
		name,
		zen_mode,
		bundle,
		saving,
		downloading,
		justSaved,
		justForked,
		wait,
		handleKeydown,
		fork,
		save,
		download,
		canSave,
		$session
	});

	$$self.$inject_state = $$props => {
		if ("repl" in $$props) $$invalidate(13, repl = $$props.repl);
		if ("gist" in $$props) $$invalidate(14, gist = $$props.gist);
		if ("name" in $$props) $$invalidate(0, name = $$props.name);
		if ("zen_mode" in $$props) $$invalidate(1, zen_mode = $$props.zen_mode);
		if ("bundle" in $$props) $$invalidate(15, bundle = $$props.bundle);
		if ("saving" in $$props) $$invalidate(3, saving = $$props.saving);
		if ("downloading" in $$props) $$invalidate(4, downloading = $$props.downloading);
		if ("justSaved" in $$props) $$invalidate(5, justSaved = $$props.justSaved);
		if ("justForked" in $$props) $$invalidate(6, justForked = $$props.justForked);
		if ("canSave" in $$props) canSave = $$props.canSave;
	};

	let canSave;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$session, gist*/ 16388) {
			 canSave = $session.user && gist && gist.owner === $session.user.uid;
		}
	};

	return [
		name,
		zen_mode,
		$session,
		saving,
		downloading,
		justSaved,
		justForked,
		session,
		login,
		handleKeydown,
		fork,
		save,
		download,
		repl,
		gist,
		bundle,
		input_input_handler,
		click_handler,
		click_handler_1
	];
}

class AppControls extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			repl: 13,
			gist: 14,
			name: 0,
			zen_mode: 1,
			bundle: 15
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AppControls",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*repl*/ ctx[13] === undefined && !("repl" in props)) {
			console.warn("<AppControls> was created without expected prop 'repl'");
		}

		if (/*gist*/ ctx[14] === undefined && !("gist" in props)) {
			console.warn("<AppControls> was created without expected prop 'gist'");
		}

		if (/*name*/ ctx[0] === undefined && !("name" in props)) {
			console.warn("<AppControls> was created without expected prop 'name'");
		}

		if (/*zen_mode*/ ctx[1] === undefined && !("zen_mode" in props)) {
			console.warn("<AppControls> was created without expected prop 'zen_mode'");
		}

		if (/*bundle*/ ctx[15] === undefined && !("bundle" in props)) {
			console.warn("<AppControls> was created without expected prop 'bundle'");
		}
	}

	get repl() {
		throw new Error_1("<AppControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set repl(value) {
		throw new Error_1("<AppControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get gist() {
		throw new Error_1("<AppControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gist(value) {
		throw new Error_1("<AppControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error_1("<AppControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error_1("<AppControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get zen_mode() {
		throw new Error_1("<AppControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set zen_mode(value) {
		throw new Error_1("<AppControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bundle() {
		throw new Error_1("<AppControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bundle(value) {
		throw new Error_1("<AppControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/repl/[id]/index.svelte generated by Svelte v3.31.0 */

const { console: console_1, window: window_1 } = globals;
const file$2 = "src/routes/repl/[id]/index.svelte";

// (212:1) {#if true}
function create_if_block$2(ctx) {
	let div;
	let repl_1;
	let t;
	let if_block_anchor;
	let current;

	let repl_1_props = {
		workersUrl: "workers",
		svelteUrl: /*svelteUrl*/ ctx[6],
		rollupUrl: /*rollupUrl*/ ctx[11],
		relaxed: /*relaxed*/ ctx[8],
		fixed: /*mobile*/ ctx[7],
		injectedJS: /*mapbox_setup*/ ctx[12]
	};

	repl_1 = new Repl({ props: repl_1_props, $$inline: true });
	/*repl_1_binding*/ ctx[20](repl_1);
	let if_block = /*mobile*/ ctx[7] && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			create_component(repl_1.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(repl_1.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "viewport svelte-13ln553");
			toggle_class(div, "offset", /*checked*/ ctx[5]);
			add_location(div, file$2, 212, 2, 4696);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(repl_1, div, null);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const repl_1_changes = {};
			if (dirty & /*svelteUrl*/ 64) repl_1_changes.svelteUrl = /*svelteUrl*/ ctx[6];
			if (dirty & /*relaxed*/ 256) repl_1_changes.relaxed = /*relaxed*/ ctx[8];
			if (dirty & /*mobile*/ 128) repl_1_changes.fixed = /*mobile*/ ctx[7];
			repl_1.$set(repl_1_changes);

			if (dirty & /*checked*/ 32) {
				toggle_class(div, "offset", /*checked*/ ctx[5]);
			}

			if (/*mobile*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*mobile*/ 128) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(repl_1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(repl_1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*repl_1_binding*/ ctx[20](null);
			destroy_component(repl_1);
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(212:1) {#if true}",
		ctx
	});

	return block;
}

// (225:2) {#if mobile}
function create_if_block_1$1(ctx) {
	let inputoutputtoggle;
	let updating_checked;
	let current;

	function inputoutputtoggle_checked_binding(value) {
		/*inputoutputtoggle_checked_binding*/ ctx[21].call(null, value);
	}

	let inputoutputtoggle_props = {};

	if (/*checked*/ ctx[5] !== void 0) {
		inputoutputtoggle_props.checked = /*checked*/ ctx[5];
	}

	inputoutputtoggle = new InputOutputToggle({
			props: inputoutputtoggle_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(inputoutputtoggle, "checked", inputoutputtoggle_checked_binding));

	const block = {
		c: function create() {
			create_component(inputoutputtoggle.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(inputoutputtoggle.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(inputoutputtoggle, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const inputoutputtoggle_changes = {};

			if (!updating_checked && dirty & /*checked*/ 32) {
				updating_checked = true;
				inputoutputtoggle_changes.checked = /*checked*/ ctx[5];
				add_flush_callback(() => updating_checked = false);
			}

			inputoutputtoggle.$set(inputoutputtoggle_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(inputoutputtoggle.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(inputoutputtoggle.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(inputoutputtoggle, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(225:2) {#if mobile}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let title_value;
	let meta0;
	let meta1;
	let meta2;
	let t0;
	let div;
	let appcontrols;
	let updating_name;
	let updating_zen_mode;
	let t1;
	let div_class_value;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[17]);
	document.title = title_value = "" + (/*name*/ ctx[3] + " • REPL • Svelte");

	function appcontrols_name_binding(value) {
		/*appcontrols_name_binding*/ ctx[18].call(null, value);
	}

	function appcontrols_zen_mode_binding(value) {
		/*appcontrols_zen_mode_binding*/ ctx[19].call(null, value);
	}

	let appcontrols_props = {
		gist: /*gist*/ ctx[0],
		repl: /*repl*/ ctx[2]
	};

	if (/*name*/ ctx[3] !== void 0) {
		appcontrols_props.name = /*name*/ ctx[3];
	}

	if (/*zen_mode*/ ctx[4] !== void 0) {
		appcontrols_props.zen_mode = /*zen_mode*/ ctx[4];
	}

	appcontrols = new AppControls({ props: appcontrols_props, $$inline: true });
	binding_callbacks.push(() => bind(appcontrols, "name", appcontrols_name_binding));
	binding_callbacks.push(() => bind(appcontrols, "zen_mode", appcontrols_zen_mode_binding));
	appcontrols.$on("forked", /*handle_fork*/ ctx[10]);
	let if_block =  create_if_block$2(ctx);

	const block = {
		c: function create() {
			meta0 = element("meta");
			meta1 = element("meta");
			meta2 = element("meta");
			t0 = space();
			div = element("div");
			create_component(appcontrols.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-d7d7y5\"]", document.head);
			meta0 = claim_element(head_nodes, "META", { name: true, content: true });
			meta1 = claim_element(head_nodes, "META", { name: true, content: true });
			meta2 = claim_element(head_nodes, "META", { name: true, content: true });
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(appcontrols.$$.fragment, div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(meta0, "name", "twitter:title");
			attr_dev(meta0, "content", "Svelte REPL");
			add_location(meta0, file$2, 195, 1, 4271);
			attr_dev(meta1, "name", "twitter:description");
			attr_dev(meta1, "content", "Cybernetically enhanced web apps");
			add_location(meta1, file$2, 196, 1, 4322);
			attr_dev(meta2, "name", "Description");
			attr_dev(meta2, "content", "Interactive Svelte playground");
			add_location(meta2, file$2, 197, 1, 4400);
			attr_dev(div, "class", div_class_value = "repl-outer " + (/*zen_mode*/ ctx[4] ? "zen-mode" : "") + " svelte-13ln553");
			toggle_class(div, "mobile", /*mobile*/ ctx[7]);
			add_location(div, file$2, 202, 0, 4524);
		},
		m: function mount(target, anchor) {
			append_dev(document.head, meta0);
			append_dev(document.head, meta1);
			append_dev(document.head, meta2);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			mount_component(appcontrols, div, null);
			append_dev(div, t1);
			if (if_block) if_block.m(div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(window_1, "resize", /*onwindowresize*/ ctx[17]);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*name*/ 8) && title_value !== (title_value = "" + (/*name*/ ctx[3] + " • REPL • Svelte"))) {
				document.title = title_value;
			}

			const appcontrols_changes = {};
			if (dirty & /*gist*/ 1) appcontrols_changes.gist = /*gist*/ ctx[0];
			if (dirty & /*repl*/ 4) appcontrols_changes.repl = /*repl*/ ctx[2];

			if (!updating_name && dirty & /*name*/ 8) {
				updating_name = true;
				appcontrols_changes.name = /*name*/ ctx[3];
				add_flush_callback(() => updating_name = false);
			}

			if (!updating_zen_mode && dirty & /*zen_mode*/ 16) {
				updating_zen_mode = true;
				appcontrols_changes.zen_mode = /*zen_mode*/ ctx[4];
				add_flush_callback(() => updating_zen_mode = false);
			}

			appcontrols.$set(appcontrols_changes);
			if_block.p(ctx, dirty);

			if (!current || dirty & /*zen_mode*/ 16 && div_class_value !== (div_class_value = "repl-outer " + (/*zen_mode*/ ctx[4] ? "zen-mode" : "") + " svelte-13ln553")) {
				attr_dev(div, "class", div_class_value);
			}

			if (dirty & /*zen_mode, mobile*/ 144) {
				toggle_class(div, "mobile", /*mobile*/ ctx[7]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(appcontrols.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(appcontrols.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			detach_dev(meta0);
			detach_dev(meta1);
			detach_dev(meta2);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			destroy_component(appcontrols);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function preload({ params, query }) {
	return {
		version: query.version || "3",
		id: params.id
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let $session;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("U5Bidu5D", slots, []);
	let { version } = $$props;
	let { id } = $$props;
	const { session } = stores$1();
	validate_store(session, "session");
	component_subscribe($$self, session, value => $$invalidate(16, $session = value));
	let repl;
	let gist;
	let name = "Loading...";
	let zen_mode = false;
	let is_relaxed_gist = false;
	let width =  window.innerWidth ;
	let checked = false;

	function update_query_string(version) {
		const params = [];
		if (version !== "latest") params.push(`version=${version}`);

		const url = params.length > 0
		? `repl/${id}?${params.join("&")}`
		: `repl/${id}`;

		history.replaceState({}, "x", url);
	}

	function fetch_gist(id) {
		if (gist && gist.uid === id) {
			// if the id changed because we just forked, don't refetch
			return;
		}

		// TODO handle `relaxed` logic
		fetch(`repl/${id}.json`).then(r => {
			if (r.ok) {
				r.json().then(data => {
					$$invalidate(0, gist = data);
					$$invalidate(3, name = data.name);
					$$invalidate(15, is_relaxed_gist = data.relaxed);

					const components = data.files.map(file => {
						const dot = file.name.lastIndexOf(".");
						let name = file.name.slice(0, dot);
						let type = file.name.slice(dot + 1);
						if (type === "html") type = "svelte"; // TODO do this on the server
						return { name, type, source: file.source };
					});

					components.sort((a, b) => {
						if (a.name === "App" && a.type === "svelte") return -1;
						if (b.name === "App" && b.type === "svelte") return 1;
						if (a.type !== b.type) return a.type === "svelte" ? -1 : 1;
						return a.name < b.name ? -1 : 1;
					});

					repl.set({ components });
				});
			} else {
				console.warn("TODO: 404 Gist");
			}
		});
	}

	onMount(() => {
		if (version !== "local") {
			fetch(`https://unpkg.com/svelte@${version || "3"}/package.json`).then(r => r.json()).then(pkg => {
				$$invalidate(13, version = pkg.version);
			});
		}
	});

	function handle_fork(event) {
		console.log("> handle_fork", event);
		$$invalidate(0, gist = event.detail.gist);
		goto(`/repl/${gist.uid}?version=${version}`);
	}

	const rollupUrl = `https://unpkg.com/rollup@1/dist/rollup.browser.js`;

	// needed for context API example
	const mapbox_setup = `window.MAPBOX_ACCESS_TOKEN = undefined;`;

	const writable_props = ["version", "id"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<U5Bidu5D> was created with unknown prop '${key}'`);
	});

	function onwindowresize() {
		$$invalidate(1, width = window_1.innerWidth);
	}

	function appcontrols_name_binding(value) {
		name = value;
		$$invalidate(3, name);
	}

	function appcontrols_zen_mode_binding(value) {
		zen_mode = value;
		$$invalidate(4, zen_mode);
	}

	function repl_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			repl = $$value;
			$$invalidate(2, repl);
		});
	}

	function inputoutputtoggle_checked_binding(value) {
		checked = value;
		$$invalidate(5, checked);
	}

	$$self.$$set = $$props => {
		if ("version" in $$props) $$invalidate(13, version = $$props.version);
		if ("id" in $$props) $$invalidate(14, id = $$props.id);
	};

	$$self.$capture_state = () => ({
		preload,
		Repl,
		onMount,
		goto,
		stores: stores$1,
		InputOutputToggle,
		AppControls,
		version,
		id,
		session,
		repl,
		gist,
		name,
		zen_mode,
		is_relaxed_gist,
		width,
		checked,
		update_query_string,
		fetch_gist,
		handle_fork,
		rollupUrl,
		mapbox_setup,
		svelteUrl,
		mobile,
		relaxed,
		$session
	});

	$$self.$inject_state = $$props => {
		if ("version" in $$props) $$invalidate(13, version = $$props.version);
		if ("id" in $$props) $$invalidate(14, id = $$props.id);
		if ("repl" in $$props) $$invalidate(2, repl = $$props.repl);
		if ("gist" in $$props) $$invalidate(0, gist = $$props.gist);
		if ("name" in $$props) $$invalidate(3, name = $$props.name);
		if ("zen_mode" in $$props) $$invalidate(4, zen_mode = $$props.zen_mode);
		if ("is_relaxed_gist" in $$props) $$invalidate(15, is_relaxed_gist = $$props.is_relaxed_gist);
		if ("width" in $$props) $$invalidate(1, width = $$props.width);
		if ("checked" in $$props) $$invalidate(5, checked = $$props.checked);
		if ("svelteUrl" in $$props) $$invalidate(6, svelteUrl = $$props.svelteUrl);
		if ("mobile" in $$props) $$invalidate(7, mobile = $$props.mobile);
		if ("relaxed" in $$props) $$invalidate(8, relaxed = $$props.relaxed);
	};

	let svelteUrl;
	let mobile;
	let relaxed;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*version*/ 8192) {
			 if (typeof history !== "undefined") update_query_string(version);
		}

		if ($$self.$$.dirty & /*id*/ 16384) {
			 fetch_gist(id);
		}

		if ($$self.$$.dirty & /*version*/ 8192) {
			 $$invalidate(6, svelteUrl =  version === "local"
			? `${location.origin}/repl/local`
			: `https://unpkg.com/svelte@${version}`);
		}

		if ($$self.$$.dirty & /*width*/ 2) {
			 $$invalidate(7, mobile = width < 540);
		}

		if ($$self.$$.dirty & /*is_relaxed_gist, $session, gist*/ 98305) {
			 $$invalidate(8, relaxed = is_relaxed_gist || $session.user && gist && $session.user.uid === gist.owner);
		}
	};

	return [
		gist,
		width,
		repl,
		name,
		zen_mode,
		checked,
		svelteUrl,
		mobile,
		relaxed,
		session,
		handle_fork,
		rollupUrl,
		mapbox_setup,
		version,
		id,
		is_relaxed_gist,
		$session,
		onwindowresize,
		appcontrols_name_binding,
		appcontrols_zen_mode_binding,
		repl_1_binding,
		inputoutputtoggle_checked_binding
	];
}

class U5Bidu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { version: 13, id: 14 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Bidu5D",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*version*/ ctx[13] === undefined && !("version" in props)) {
			console_1.warn("<U5Bidu5D> was created without expected prop 'version'");
		}

		if (/*id*/ ctx[14] === undefined && !("id" in props)) {
			console_1.warn("<U5Bidu5D> was created without expected prop 'id'");
		}
	}

	get version() {
		throw new Error("<U5Bidu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set version(value) {
		throw new Error("<U5Bidu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<U5Bidu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<U5Bidu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default U5Bidu5D;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguMzEzY2E5ZTEuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvcmVwbC9baWRdL19jb21wb25lbnRzL0FwcENvbnRyb2xzL1VzZXJNZW51LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kby1ub3QtemlwL2Rpc3QvaW5kZXguZXMuanMiLCIuLi8uLi8uLi9zcmMvcm91dGVzL3JlcGwvX3V0aWxzL2Rvd25sb2FkQmxvYi5qcyIsIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMuanMiLCIuLi8uLi8uLi9zcmMvdXRpbHMvY29tcGF0LmpzIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9yZXBsL1tpZF0vX2NvbXBvbmVudHMvQXBwQ29udHJvbHMvaW5kZXguc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9yZXBsL1tpZF0vaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyBzdG9yZXMgfSBmcm9tICdAc2FwcGVyL2FwcCc7XG5cdGNvbnN0IHsgc2Vzc2lvbiB9ID0gc3RvcmVzKCk7XG5cblx0Y29uc3QgeyBsb2dvdXQgfSA9IGdldENvbnRleHQoJ2FwcCcpO1xuXG5cdGxldCBzaG93TWVudSA9IGZhbHNlO1xuXHRsZXQgbmFtZTtcblxuXHQkOiBuYW1lID0gJHNlc3Npb24udXNlci5uYW1lIHx8ICRzZXNzaW9uLnVzZXIudXNlcm5hbWU7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInVzZXJcIiBvbjptb3VzZWVudGVyPVwieygpID0+IHNob3dNZW51ID0gdHJ1ZX1cIiBvbjptb3VzZWxlYXZlPVwieygpID0+IHNob3dNZW51ID0gZmFsc2V9XCI+XG5cdDxzcGFuPntuYW1lfTwvc3Bhbj5cblx0PGltZyBhbHQ9XCJ7bmFtZX0gYXZhdGFyXCIgc3JjPVwieyRzZXNzaW9uLnVzZXIuYXZhdGFyfVwiPlxuXG5cdHsjaWYgc2hvd01lbnV9XG5cdFx0PGRpdiBjbGFzcz1cIm1lbnVcIj5cblx0XHRcdDxhIGhyZWY9XCJhcHBzXCI+WW91ciBzYXZlZCBhcHBzPC9hPlxuXHRcdFx0PGJ1dHRvbiBvbjpjbGljaz17bG9nb3V0fT5Mb2cgb3V0PC9idXR0b24+XG5cdFx0PC9kaXY+XG5cdHsvaWZ9XG48L2Rpdj5cblxuPHN0eWxlPlxuXHQudXNlciB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0XHRwYWRkaW5nOiAwZW0gMS4ycmVtIDAgMS42cmVtO1xuXHRcdGhlaWdodDogMC44ZW07XG5cdFx0bGluZS1oZWlnaHQ6IDE7XG5cdFx0ei1pbmRleDogOTk7XG5cdH1cblxuXHQudXNlcjo6YWZ0ZXIge1xuXHRcdC8qIGVtYmlnZ2VuIGhpdCB6b25lLCBzbyBsb2cgb3V0IG1lbnUgZG9lc24ndCBkaXNhcHBlYXIgKi9cblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0Y29udGVudDogJyc7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAzLjJyZW07XG5cdFx0bGVmdDogMDtcblx0XHR0b3A6IDA7XG5cdH1cblxuXHRzcGFuIHtcblx0XHQvKiBwb3NpdGlvbjogcmVsYXRpdmU7IHBhZGRpbmc6IDAgMmVtIDAgMDsgKi9cblx0XHRsaW5lLWhlaWdodDogMTtcblx0XHRkaXNwbGF5OiBub25lO1xuXHRcdGZvbnQtZmFtaWx5OiB2YXIoLS1mb250KTtcblx0XHRmb250LXNpemU6IDEuNnJlbTtcblx0XHRvcGFjaXR5OiAwLjc7XG5cdH1cblxuXHQudXNlcjpob3ZlciBzcGFuIHtcblx0XHRvcGFjaXR5OiAxO1xuXHR9XG5cblx0aW1nIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAtMC4wNWVtO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHdpZHRoOiAyLjFyZW07XG5cdFx0aGVpZ2h0OiAyLjFyZW07XG5cdFx0Ym9yZGVyOiAxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjMpO1xuXHRcdGJvcmRlci1yYWRpdXM6IDAuMnJlbTtcblx0fVxuXG5cdC5tZW51IHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0d2lkdGg6IGNhbGMoMTAwJSArIDEuNnJlbSk7XG5cdFx0bWluLXdpZHRoOiAxMGVtO1xuXHRcdHRvcDogM3JlbTtcblx0XHRyaWdodDogLTEuNnJlbTtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zZWNvbmQpO1xuXHRcdHBhZGRpbmc6IDAuOHJlbSAxLjZyZW07XG5cdFx0ei1pbmRleDogOTk7XG5cdFx0dGV4dC1hbGlnbjogbGVmdDtcblx0XHRib3JkZXItcmFkaXVzOiAwLjRyZW07XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHR9XG5cblx0Lm1lbnUgYnV0dG9uLCAubWVudSBhIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHRmb250LWZhbWlseTogdmFyKC0tZm9udCk7XG5cdFx0Zm9udC1zaXplOiAxLjZyZW07XG5cdFx0b3BhY2l0eTogMC43O1xuXHRcdHBhZGRpbmc6IDAuNHJlbSAwO1xuXHRcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcblx0XHR0ZXh0LWFsaWduOiBsZWZ0O1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHRjb2xvcjogaW5oZXJpdDtcblx0fVxuXG5cdC5tZW51IGJ1dHRvbjpob3ZlciwgLm1lbnUgYTpob3ZlciB7XG5cdFx0b3BhY2l0eTogMTtcblx0XHRjb2xvcjogaW5oZXJpdDtcblx0fVxuXG5cdEBtZWRpYSAobWluLXdpZHRoOiA2MDBweCkge1xuXHRcdC51c2VyIHtcblx0XHRcdHBhZGRpbmc6IDBlbSAzLjJyZW0gMCAxLjZyZW07XG5cdFx0fVxuXG5cdFx0aW1nIHtcblx0XHRcdHdpZHRoOiAyLjRyZW07XG5cdFx0XHRoZWlnaHQ6IDIuNHJlbTtcblx0XHR9XG5cblx0XHRzcGFuIHtcblx0XHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG4iLCJjb25zdCB0YWJsZSA9IFtdO1xuZm9yIChsZXQgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuXHRsZXQgYyA9IG47XG5cdGZvciAobGV0IGsgPSAwOyBrIDwgODsgaysrKSB7XG5cdFx0YyA9IGMgJiAxID8gMHhFREI4ODMyMCBeIChjID4+PiAxKSA6IGMgPj4+IDE7XG5cdH1cblx0dGFibGVbbl0gPSBjO1xufVxuXG52YXIgY3JjMzIgPSBieXRlcyA9PiB7XG5cdGxldCBzdW0gPSAtMTtcblx0Zm9yIChjb25zdCBieXRlIG9mIGJ5dGVzKSB7XG5cdFx0c3VtID0gKHN1bSA+Pj4gOCkgXiB0YWJsZVsoc3VtIF4gYnl0ZSkgJiAweEZGXTtcblx0fVxuXHRyZXR1cm4gc3VtIF4gLTE7XG59O1xuXG5jb25zdCBpbnQgPSAobiwgbGVuZ3RoKSA9PiB7XG5cdGNvbnN0IG91dCA9IFtdO1xuXHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRvdXQucHVzaChuICYgMHhGRik7XG5cdFx0biA+Pj49IDg7XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG5cbmNvbnN0IHRvQnl0ZXMgPSBkYXRhID0+IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IFsuLi5kYXRhXS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpIDogZGF0YTtcblxudmFyIHRvQXJyYXkgPSBmaWxlcyA9PiB7XG5cdGxldCBmaWxlRGF0YSA9IFtdO1xuXHRjb25zdCBjZW50cmFsRGlyZWN0b3J5ID0gW107XG5cdGZvciAoY29uc3QgeyBwYXRoLCBkYXRhIH0gb2YgZmlsZXMpIHtcblx0XHRjb25zdCBkYXRhQnl0ZXMgPSB0b0J5dGVzKGRhdGEpO1xuXHRcdGNvbnN0IHBhdGhCeXRlcyA9IHRvQnl0ZXMocGF0aCk7XG5cdFx0Y29uc3QgY29tbW9uSGVhZGVyID0gWzB4MEEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC4uLmludChjcmMzMihkYXRhQnl0ZXMpLCA0KSwgLi4uaW50KGRhdGFCeXRlcy5sZW5ndGgsIDQpLCAuLi5pbnQoZGF0YUJ5dGVzLmxlbmd0aCwgNCksIC4uLmludChwYXRoQnl0ZXMubGVuZ3RoLCAyKSwgMHgwMCwgMHgwMF07XG5cdFx0Y2VudHJhbERpcmVjdG9yeS5wdXNoKDB4NTAsIDB4NEIsIDB4MDEsIDB4MDIsIDB4MTQsIDB4MDAsIC4uLmNvbW1vbkhlYWRlciwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLi4uaW50KGZpbGVEYXRhLmxlbmd0aCwgNCksIC4uLnBhdGhCeXRlcyk7XG5cdFx0ZmlsZURhdGEgPSBbLi4uZmlsZURhdGEsIDB4NTAsIDB4NEIsIDB4MDMsIDB4MDQsIC4uLmNvbW1vbkhlYWRlciwgLi4ucGF0aEJ5dGVzLCAuLi5kYXRhQnl0ZXNdO1xuXHR9XG5cdHJldHVybiBbLi4uZmlsZURhdGEsIC4uLmNlbnRyYWxEaXJlY3RvcnksIDB4NTAsIDB4NEIsIDB4MDUsIDB4MDYsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC4uLmludChmaWxlcy5sZW5ndGgsIDIpLCAuLi5pbnQoZmlsZXMubGVuZ3RoLCAyKSwgLi4uaW50KGNlbnRyYWxEaXJlY3RvcnkubGVuZ3RoLCA0KSwgLi4uaW50KGZpbGVEYXRhLmxlbmd0aCwgNCksIDB4MDAsIDB4MDBdO1xufTtcblxudmFyIHRvQmxvYiA9IGZpbGVzID0+IG5ldyBCbG9iKFtVaW50OEFycmF5LmZyb20odG9BcnJheShmaWxlcykpXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vemlwJyB9KTtcblxudmFyIHRvQnVmZmVyID0gZmlsZXMgPT4gQnVmZmVyLmZyb20odG9BcnJheShmaWxlcykpO1xuXG52YXIgdG9BdXRvID0gZmlsZXMgPT4gKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJyA/IHRvQnVmZmVyIDogdG9CbG9iKShmaWxlcyk7XG5cbmV4cG9ydCB7IHRvQXJyYXksIHRvQXV0bywgdG9CbG9iLCB0b0J1ZmZlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJleHBvcnQgZGVmYXVsdCAoYmxvYiwgZmlsZW5hbWUpID0+IHtcblx0Y29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblx0Y29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0bGluay5ocmVmID0gdXJsO1xuXHRsaW5rLmRvd25sb2FkID0gZmlsZW5hbWU7XG5cdGxpbmsuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcblx0bGluay5jbGljaygpO1xuXHRVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG5cdGxpbmsucmVtb3ZlKCk7XG59O1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGtleUV2ZW50KGNvZGUpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChub2RlLCBjYWxsYmFjaykge1xuXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleWRvd24pO1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlS2V5ZG93bihldmVudCkge1xuXHRcdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IGNvZGUpIHtcblx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRlc3Ryb3koKSB7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleWRvd24pO1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG59XG5cbmV4cG9ydCBjb25zdCBlbnRlciA9IGtleUV2ZW50KDEzKTtcbiIsImV4cG9ydCBjb25zdCBpc01hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gJ01hY0ludGVsJztcbiIsIjxzY3JpcHQ+XG5cdGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7IHN0b3JlcyB9IGZyb20gJ0BzYXBwZXIvYXBwJztcblx0aW1wb3J0IFVzZXJNZW51IGZyb20gJy4vVXNlck1lbnUuc3ZlbHRlJztcblx0aW1wb3J0IHsgSWNvbiB9IGZyb20gJ0BzdmVsdGVqcy9zaXRlLWtpdCc7XG5cdGltcG9ydCAqIGFzIGRvTm90WmlwIGZyb20gJ2RvLW5vdC16aXAnO1xuXHRpbXBvcnQgZG93bmxvYWRCbG9iIGZyb20gJy4uLy4uLy4uL191dGlscy9kb3dubG9hZEJsb2IuanMnO1xuXHRpbXBvcnQgeyBlbnRlciB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3V0aWxzL2V2ZW50cy5qcyc7XG5cdGltcG9ydCB7IGlzTWFjIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbHMvY29tcGF0LmpzJztcblxuXHRjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXHRjb25zdCB7IHNlc3Npb24gfSA9IHN0b3JlcygpO1xuXHRjb25zdCB7IGxvZ2luIH0gPSBnZXRDb250ZXh0KCdhcHAnKTtcblxuXHRleHBvcnQgbGV0IHJlcGw7XG5cdGV4cG9ydCBsZXQgZ2lzdDtcblx0ZXhwb3J0IGxldCBuYW1lO1xuXHRleHBvcnQgbGV0IHplbl9tb2RlO1xuXHRleHBvcnQgbGV0IGJ1bmRsZTtcblxuXHRsZXQgc2F2aW5nID0gZmFsc2U7XG5cdGxldCBkb3dubG9hZGluZyA9IGZhbHNlO1xuXHRsZXQganVzdFNhdmVkID0gZmFsc2U7XG5cdGxldCBqdXN0Rm9ya2VkID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gd2FpdChtcykge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmID0+IHNldFRpbWVvdXQoZiwgbXMpKTtcblx0fVxuXG5cdCQ6IGNhblNhdmUgPSAkc2Vzc2lvbi51c2VyICYmIGdpc3QgJiYgZ2lzdC5vd25lciA9PT0gJHNlc3Npb24udXNlci51aWQ7XG5cblx0ZnVuY3Rpb24gaGFuZGxlS2V5ZG93bihldmVudCkge1xuXHRcdGlmIChldmVudC5rZXkgPT09ICdzJyAmJiAoaXNNYWMgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleSkpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRzYXZlKCk7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgZnVuY3Rpb24gZm9yayhpbnRlbnRXYXNTYXZlKSB7XG5cdFx0c2F2aW5nID0gdHJ1ZTtcblxuXHRcdGNvbnN0IHsgY29tcG9uZW50cyB9ID0gcmVwbC50b0pTT04oKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCByID0gYXdhaXQgZmV0Y2goYHJlcGwvY3JlYXRlLmpzb25gLCB7XG5cdFx0XHRcdG1ldGhvZDogJ1BPU1QnLFxuXHRcdFx0XHRjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuXHRcdFx0XHRib2R5OiBKU09OLnN0cmluZ2lmeSh7XG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRmaWxlczogY29tcG9uZW50cy5tYXAoY29tcG9uZW50ID0+ICh7XG5cdFx0XHRcdFx0XHRuYW1lOiBgJHtjb21wb25lbnQubmFtZX0uJHtjb21wb25lbnQudHlwZX1gLFxuXHRcdFx0XHRcdFx0c291cmNlOiBjb21wb25lbnQuc291cmNlXG5cdFx0XHRcdFx0fSkpXG5cdFx0XHRcdH0pXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHIuc3RhdHVzIDwgMjAwIHx8IHIuc3RhdHVzID49IDMwMCkge1xuXHRcdFx0XHRjb25zdCB7IGVycm9yIH0gPSBhd2FpdCByLmpzb24oKTtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBhbiBIVFRQICR7ci5zdGF0dXN9IHJlc3BvbnNlOiAke2Vycm9yfWApO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnaXN0ID0gYXdhaXQgci5qc29uKCk7XG5cdFx0XHRkaXNwYXRjaCgnZm9ya2VkJywgeyBnaXN0IH0pO1xuXG5cdFx0XHRpZiAoaW50ZW50V2FzU2F2ZSkge1xuXHRcdFx0XHRqdXN0U2F2ZWQgPSB0cnVlO1xuXHRcdFx0XHRhd2FpdCB3YWl0KDYwMCk7XG5cdFx0XHRcdGp1c3RTYXZlZCA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0anVzdEZvcmtlZCA9IHRydWU7XG5cdFx0XHRcdGF3YWl0IHdhaXQoNjAwKTtcblx0XHRcdFx0anVzdEZvcmtlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0aWYgKG5hdmlnYXRvci5vbkxpbmUpIHtcblx0XHRcdFx0YWxlcnQoZXJyLm1lc3NhZ2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWxlcnQoYEl0IGxvb2tzIGxpa2UgeW91J3JlIG9mZmxpbmUhIEZpbmQgdGhlIGludGVybmV0IGFuZCB0cnkgYWdhaW5gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzYXZpbmcgPSBmYWxzZTtcblx0fVxuXG5cdGFzeW5jIGZ1bmN0aW9uIHNhdmUoKSB7XG5cdFx0aWYgKHNhdmluZykgcmV0dXJuO1xuXG5cdFx0aWYgKCFjYW5TYXZlKSB7XG5cdFx0XHRmb3JrKHRydWUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHNhdmluZyA9IHRydWU7XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gU2VuZCBhbGwgZmlsZXMgYmFjayB0byBBUElcblx0XHRcdC8vIH4+IEFueSBtaXNzaW5nIGZpbGVzIGFyZSBjb25zaWRlcmVkIGRlbGV0ZWQhXG5cdFx0XHRjb25zdCB7IGNvbXBvbmVudHMgfSA9IHJlcGwudG9KU09OKCk7XG5cblx0XHRcdGNvbnN0IHIgPSBhd2FpdCBmZXRjaChgcmVwbC8ke2dpc3QudWlkfS5qc29uYCwge1xuXHRcdFx0XHRtZXRob2Q6ICdQQVRDSCcsXG5cdFx0XHRcdGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG5cdFx0XHRcdGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGZpbGVzOiBjb21wb25lbnRzLm1hcChjb21wb25lbnQgPT4gKHtcblx0XHRcdFx0XHRcdG5hbWU6IGAke2NvbXBvbmVudC5uYW1lfS4ke2NvbXBvbmVudC50eXBlfWAsXG5cdFx0XHRcdFx0XHRzb3VyY2U6IGNvbXBvbmVudC5zb3VyY2Vcblx0XHRcdFx0XHR9KSlcblx0XHRcdFx0fSlcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoci5zdGF0dXMgPCAyMDAgfHwgci5zdGF0dXMgPj0gMzAwKSB7XG5cdFx0XHRcdGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHIuanNvbigpO1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkIGFuIEhUVFAgJHtyLnN0YXR1c30gcmVzcG9uc2U6ICR7ZXJyb3J9YCk7XG5cdFx0XHR9XG5cblx0XHRcdGF3YWl0IHIuanNvbigpO1xuXG5cdFx0XHRqdXN0U2F2ZWQgPSB0cnVlO1xuXHRcdFx0YXdhaXQgd2FpdCg2MDApO1xuXHRcdFx0anVzdFNhdmVkID0gZmFsc2U7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRpZiAobmF2aWdhdG9yLm9uTGluZSkge1xuXHRcdFx0XHRhbGVydChlcnIubWVzc2FnZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhbGVydChgSXQgbG9va3MgbGlrZSB5b3UncmUgb2ZmbGluZSEgRmluZCB0aGUgaW50ZXJuZXQgYW5kIHRyeSBhZ2FpbmApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNhdmluZyA9IGZhbHNlO1xuXHR9XG5cblx0YXN5bmMgZnVuY3Rpb24gZG93bmxvYWQoKSB7XG5cdFx0ZG93bmxvYWRpbmcgPSB0cnVlO1xuXG5cdFx0Y29uc3QgeyBjb21wb25lbnRzLCBpbXBvcnRzIH0gPSByZXBsLnRvSlNPTigpO1xuXG5cdFx0Y29uc3QgZmlsZXMgPSBhd2FpdCAoYXdhaXQgZmV0Y2goJy9zdmVsdGUtYXBwLmpzb24nKSkuanNvbigpO1xuXG5cdFx0aWYgKGltcG9ydHMubGVuZ3RoID4gMCkge1xuXHRcdFx0Y29uc3QgaWR4ID0gZmlsZXMuZmluZEluZGV4KCh7IHBhdGggfSkgPT4gcGF0aCA9PT0gJ3BhY2thZ2UuanNvbicpO1xuXHRcdFx0Y29uc3QgcGtnID0gSlNPTi5wYXJzZShmaWxlc1tpZHhdLmRhdGEpO1xuXHRcdFx0Y29uc3QgeyBkZXZEZXBlbmRlbmNpZXMgfSA9IHBrZztcblx0XHRcdGltcG9ydHMuZm9yRWFjaChtb2QgPT4ge1xuXHRcdFx0XHRjb25zdCBtYXRjaCA9IC9eKEBbXi9dK1xcLyk/W15AL10rLy5leGVjKG1vZCk7XG5cdFx0XHRcdGRldkRlcGVuZGVuY2llc1ttYXRjaFswXV0gPSAnbGF0ZXN0Jztcblx0XHRcdH0pO1xuXHRcdFx0cGtnLmRldkRlcGVuZGVuY2llcyA9IGRldkRlcGVuZGVuY2llcztcblx0XHRcdGZpbGVzW2lkeF0uZGF0YSA9IEpTT04uc3RyaW5naWZ5KHBrZywgbnVsbCwgJyAgJyk7XG5cdFx0fVxuXG5cdFx0ZmlsZXMucHVzaCguLi5jb21wb25lbnRzLm1hcChjb21wb25lbnQgPT4gKHsgcGF0aDogYHNyYy8ke2NvbXBvbmVudC5uYW1lfS4ke2NvbXBvbmVudC50eXBlfWAsIGRhdGE6IGNvbXBvbmVudC5zb3VyY2UgfSkpKTtcblx0XHRmaWxlcy5wdXNoKHtcblx0XHRcdHBhdGg6IGBzcmMvbWFpbi5qc2AsIGRhdGE6IGBpbXBvcnQgQXBwIGZyb20gJy4vQXBwLnN2ZWx0ZSc7XG5cbnZhciBhcHAgPSBuZXcgQXBwKHtcblx0dGFyZ2V0OiBkb2N1bWVudC5ib2R5XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXBwO2AgfSk7XG5cblx0XHRkb3dubG9hZEJsb2IoZG9Ob3RaaXAudG9CbG9iKGZpbGVzKSwgJ3N2ZWx0ZS1hcHAuemlwJyk7XG5cblx0XHRkb3dubG9hZGluZyA9IGZhbHNlO1xuXHR9XG48L3NjcmlwdD5cblxuPHN2ZWx0ZTp3aW5kb3cgb246a2V5ZG93bj17aGFuZGxlS2V5ZG93bn0gLz5cblxuPGRpdiBjbGFzcz1cImFwcC1jb250cm9sc1wiPlxuXHQ8aW5wdXRcblx0XHRiaW5kOnZhbHVlPXtuYW1lfVxuXHRcdG9uOmZvY3VzPVwie2UgPT4gZS50YXJnZXQuc2VsZWN0KCl9XCJcblx0XHR1c2U6ZW50ZXI9XCJ7ZSA9PiBlLnRhcmdldC5ibHVyKCl9XCJcblx0PlxuXG5cdDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOiByaWdodDsgbWFyZ2luLXJpZ2h0Oi40cmVtXCI+XG5cdFx0PGJ1dHRvbiBjbGFzcz1cImljb25cIiBvbjpjbGljaz1cInsoKSA9PiB6ZW5fbW9kZSA9ICF6ZW5fbW9kZX1cIiB0aXRsZT1cImZ1bGxzY3JlZW4gZWRpdG9yXCI+XG5cdFx0XHR7I2lmIHplbl9tb2RlfVxuXHRcdFx0XHQ8SWNvbiBuYW1lPVwiY2xvc2VcIiAvPlxuXHRcdFx0ezplbHNlfVxuXHRcdFx0XHQ8SWNvbiBuYW1lPVwibWF4aW1pemVcIiAvPlxuXHRcdFx0ey9pZn1cblx0XHQ8L2J1dHRvbj5cblxuXHRcdDxidXR0b24gY2xhc3M9XCJpY29uXCIgZGlzYWJsZWQ9e2Rvd25sb2FkaW5nfSBvbjpjbGljaz17ZG93bmxvYWR9IHRpdGxlPVwiZG93bmxvYWQgemlwIGZpbGVcIj5cblx0XHRcdDxJY29uIG5hbWU9XCJkb3dubG9hZFwiIC8+XG5cdFx0PC9idXR0b24+XG5cblx0XHQ8YnV0dG9uIGNsYXNzPVwiaWNvblwiIGRpc2FibGVkPVwie3NhdmluZyB8fCAhJHNlc3Npb24udXNlcn1cIiBvbjpjbGljaz17KCkgPT4gZm9yayhmYWxzZSl9IHRpdGxlPVwiZm9ya1wiPlxuXHRcdFx0eyNpZiBqdXN0Rm9ya2VkfVxuXHRcdFx0XHQ8SWNvbiBuYW1lPVwiY2hlY2tcIiAvPlxuXHRcdFx0ezplbHNlfVxuXHRcdFx0XHQ8SWNvbiBuYW1lPVwiZ2l0LWJyYW5jaFwiIC8+XG5cdFx0XHR7L2lmfVxuXHRcdDwvYnV0dG9uPlxuXG5cdFx0PGJ1dHRvbiBjbGFzcz1cImljb25cIiBkaXNhYmxlZD1cIntzYXZpbmcgfHwgISRzZXNzaW9uLnVzZXJ9XCIgb246Y2xpY2s9e3NhdmV9IHRpdGxlPVwic2F2ZVwiPlxuXHRcdFx0eyNpZiBqdXN0U2F2ZWR9XG5cdFx0XHRcdDxJY29uIG5hbWU9XCJjaGVja1wiIC8+XG5cdFx0XHR7OmVsc2V9XG5cdFx0XHRcdDxJY29uIG5hbWU9XCJzYXZlXCIgLz5cblx0XHRcdHsvaWZ9XG5cdFx0PC9idXR0b24+XG5cblx0XHR7I2lmICRzZXNzaW9uLnVzZXJ9XG5cdFx0XHQ8VXNlck1lbnUvPlxuXHRcdHs6ZWxzZX1cblx0XHRcdDxidXR0b24gY2xhc3M9XCJpY29uXCIgb246Y2xpY2t8cHJldmVudERlZmF1bHQ9e2xvZ2lufT5cblx0XHRcdFx0PEljb24gbmFtZT1cImxvZy1pblwiIC8+XG5cdFx0XHRcdDxzcGFuPiZuYnNwO0xvZyBpbiB0byBzYXZlPC9zcGFuPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0ey9pZn1cblx0PC9kaXY+XG48L2Rpdj5cblxuPHN0eWxlPlxuXHQuYXBwLWNvbnRyb2xzIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiB2YXIoLS1hcHAtY29udHJvbHMtaCk7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcblx0XHRwYWRkaW5nOiAuNnJlbSB2YXIoLS1zaWRlLW5hdik7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kKTtcblx0XHRjb2xvcjogd2hpdGU7XG5cdFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRmbGV4OiAwO1xuXHR9XG5cblx0Lmljb24ge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHR0b3A6IC0wLjFyZW07XG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRcdHBhZGRpbmc6IDAuMmVtO1xuXHRcdG9wYWNpdHk6IC43O1xuXHRcdHRyYW5zaXRpb246IG9wYWNpdHkgLjNzO1xuXHRcdGZvbnQtZmFtaWx5OiB2YXIoLS1mb250KTtcblx0XHRmb250LXNpemU6IDEuNnJlbTtcblx0XHRjb2xvcjogd2hpdGU7XG5cdFx0Lyogd2lkdGg6IDEuNmVtO1xuXHRcdGhlaWdodDogMS42ZW07ICovXG5cdFx0bGluZS1oZWlnaHQ6IDE7XG5cdFx0bWFyZ2luOiAwIDAgMCAwLjJlbTtcblx0fVxuXG5cdC5pY29uOmhvdmVyICAgIHsgb3BhY2l0eTogMSB9XG5cdC5pY29uOmRpc2FibGVkIHsgb3BhY2l0eTogLjMgfVxuXG5cdC5pY29uW3RpdGxlXj0nZnVsbHNjcmVlbiddIHsgZGlzcGxheTogbm9uZSB9XG5cblx0aW5wdXQge1xuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHRjb2xvcjogY3VycmVudENvbG9yO1xuXHRcdGZvbnQtZmFtaWx5OiB2YXIoLS1mb250KTtcblx0XHRmb250LXNpemU6IDEuNnJlbTtcblx0XHRvcGFjaXR5OiAwLjc7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHRmbGV4OiAxO1xuXHR9XG5cblx0aW5wdXQ6Zm9jdXMge1xuXHRcdG9wYWNpdHk6IDE7XG5cdH1cblxuXHRidXR0b24gc3BhbiB7XG5cdFx0ZGlzcGxheTogbm9uZTtcblx0fVxuXG5cdEBtZWRpYSAobWluLXdpZHRoOiA2MDBweCkge1xuXHRcdC5pY29uW3RpdGxlXj0nZnVsbHNjcmVlbiddIHsgZGlzcGxheTogaW5saW5lIH1cblxuXHRcdGJ1dHRvbiBzcGFuIHtcblx0XHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cblx0ZXhwb3J0IGZ1bmN0aW9uIHByZWxvYWQoeyBwYXJhbXMsIHF1ZXJ5IH0pIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmVyc2lvbjogcXVlcnkudmVyc2lvbiB8fCAnMycsXG5cdFx0XHRpZDogcGFyYW1zLmlkXG5cdFx0fTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQ+XG5cdGltcG9ydCBSZXBsIGZyb20gJ0BzdmVsdGVqcy9zdmVsdGUtcmVwbCc7XG5cdGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyBnb3RvLCBzdG9yZXMgfSBmcm9tICdAc2FwcGVyL2FwcCc7XG5cdGltcG9ydCBJbnB1dE91dHB1dFRvZ2dsZSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL1JlcGwvSW5wdXRPdXRwdXRUb2dnbGUuc3ZlbHRlJztcblx0aW1wb3J0IEFwcENvbnRyb2xzIGZyb20gJy4vX2NvbXBvbmVudHMvQXBwQ29udHJvbHMvaW5kZXguc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IHZlcnNpb247XG5cdGV4cG9ydCBsZXQgaWQ7XG5cblx0Y29uc3QgeyBzZXNzaW9uIH0gPSBzdG9yZXMoKTtcblxuXHRsZXQgcmVwbDtcblx0bGV0IGdpc3Q7XG5cdGxldCBuYW1lID0gJ0xvYWRpbmcuLi4nO1xuXHRsZXQgemVuX21vZGUgPSBmYWxzZTtcblx0bGV0IGlzX3JlbGF4ZWRfZ2lzdCA9IGZhbHNlO1xuXHRsZXQgd2lkdGggPSBwcm9jZXNzLmJyb3dzZXIgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IDEwMDA7XG5cdGxldCBjaGVja2VkID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gdXBkYXRlX3F1ZXJ5X3N0cmluZyh2ZXJzaW9uKSB7XG5cdFx0Y29uc3QgcGFyYW1zID0gW107XG5cblx0XHRpZiAodmVyc2lvbiAhPT0gJ2xhdGVzdCcpIHBhcmFtcy5wdXNoKGB2ZXJzaW9uPSR7dmVyc2lvbn1gKTtcblxuXHRcdGNvbnN0IHVybCA9IHBhcmFtcy5sZW5ndGggPiAwXG5cdFx0XHQ/IGByZXBsLyR7aWR9PyR7cGFyYW1zLmpvaW4oJyYnKX1gXG5cdFx0XHQ6IGByZXBsLyR7aWR9YDtcblxuXHRcdGhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAneCcsIHVybCk7XG5cdH1cblxuXHQkOiBpZiAodHlwZW9mIGhpc3RvcnkgIT09ICd1bmRlZmluZWQnKSB1cGRhdGVfcXVlcnlfc3RyaW5nKHZlcnNpb24pO1xuXG5cdGZ1bmN0aW9uIGZldGNoX2dpc3QoaWQpIHtcblx0XHRpZiAoZ2lzdCAmJiBnaXN0LnVpZCA9PT0gaWQpIHtcblx0XHRcdC8vIGlmIHRoZSBpZCBjaGFuZ2VkIGJlY2F1c2Ugd2UganVzdCBmb3JrZWQsIGRvbid0IHJlZmV0Y2hcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBUT0RPIGhhbmRsZSBgcmVsYXhlZGAgbG9naWNcblx0XHRmZXRjaChgcmVwbC8ke2lkfS5qc29uYCkudGhlbihyID0+IHtcblx0XHRcdGlmIChyLm9rKSB7XG5cdFx0XHRcdHIuanNvbigpLnRoZW4oZGF0YSA9PiB7XG5cdFx0XHRcdFx0Z2lzdCA9IGRhdGE7XG5cdFx0XHRcdFx0bmFtZSA9IGRhdGEubmFtZTtcblxuXHRcdFx0XHRcdGlzX3JlbGF4ZWRfZ2lzdCA9IGRhdGEucmVsYXhlZDtcblxuXHRcdFx0XHRcdGNvbnN0IGNvbXBvbmVudHMgPSBkYXRhLmZpbGVzLm1hcChmaWxlID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGRvdCA9IGZpbGUubmFtZS5sYXN0SW5kZXhPZihcIi5cIik7XG5cdFx0XHRcdFx0XHRsZXQgbmFtZSA9IGZpbGUubmFtZS5zbGljZSgwLCBkb3QpO1xuXHRcdFx0XHRcdFx0bGV0IHR5cGUgPSBmaWxlLm5hbWUuc2xpY2UoZG90ICsgMSk7XG5cblx0XHRcdFx0XHRcdGlmICh0eXBlID09PSAnaHRtbCcpIHR5cGUgPSAnc3ZlbHRlJzsgLy8gVE9ETyBkbyB0aGlzIG9uIHRoZSBzZXJ2ZXJcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWUsIHR5cGUsIHNvdXJjZTogZmlsZS5zb3VyY2UgfTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGNvbXBvbmVudHMuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGEubmFtZSA9PT0gJ0FwcCcgJiYgYS50eXBlID09PSAnc3ZlbHRlJykgcmV0dXJuIC0xO1xuXHRcdFx0XHRcdFx0aWYgKGIubmFtZSA9PT0gJ0FwcCcgJiYgYi50eXBlID09PSAnc3ZlbHRlJykgcmV0dXJuIDE7XG5cblx0XHRcdFx0XHRcdGlmIChhLnR5cGUgIT09IGIudHlwZSkgcmV0dXJuIGEudHlwZSA9PT0gJ3N2ZWx0ZScgPyAtMSA6IDE7XG5cblx0XHRcdFx0XHRcdHJldHVybiBhLm5hbWUgPCBiLm5hbWUgPyAtMSA6IDE7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRyZXBsLnNldCh7IGNvbXBvbmVudHMgfSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUT0RPOiA0MDQgR2lzdCcpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0JDogaWYgKHByb2Nlc3MuYnJvd3NlcikgZmV0Y2hfZ2lzdChpZCk7XG5cblx0b25Nb3VudCgoKSA9PiB7XG5cdFx0aWYgKHZlcnNpb24gIT09ICdsb2NhbCcpIHtcblx0XHRcdGZldGNoKGBodHRwczovL3VucGtnLmNvbS9zdmVsdGVAJHt2ZXJzaW9uIHx8ICczJ30vcGFja2FnZS5qc29uYClcblx0XHRcdFx0LnRoZW4ociA9PiByLmpzb24oKSlcblx0XHRcdFx0LnRoZW4ocGtnID0+IHtcblx0XHRcdFx0XHR2ZXJzaW9uID0gcGtnLnZlcnNpb247XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gaGFuZGxlX2ZvcmsoZXZlbnQpIHtcblx0XHRjb25zb2xlLmxvZygnPiBoYW5kbGVfZm9yaycsIGV2ZW50KTtcblx0XHRnaXN0ID0gZXZlbnQuZGV0YWlsLmdpc3Q7XG5cdFx0Z290byhgL3JlcGwvJHtnaXN0LnVpZH0/dmVyc2lvbj0ke3ZlcnNpb259YCk7XG5cdH1cblxuXHQkOiBzdmVsdGVVcmwgPSBwcm9jZXNzLmJyb3dzZXIgJiYgdmVyc2lvbiA9PT0gJ2xvY2FsJyA/XG5cdFx0YCR7bG9jYXRpb24ub3JpZ2lufS9yZXBsL2xvY2FsYCA6XG5cdFx0YGh0dHBzOi8vdW5wa2cuY29tL3N2ZWx0ZUAke3ZlcnNpb259YDtcblxuXHRjb25zdCByb2xsdXBVcmwgPSBgaHR0cHM6Ly91bnBrZy5jb20vcm9sbHVwQDEvZGlzdC9yb2xsdXAuYnJvd3Nlci5qc2A7XG5cblx0Ly8gbmVlZGVkIGZvciBjb250ZXh0IEFQSSBleGFtcGxlXG5cdGNvbnN0IG1hcGJveF9zZXR1cCA9IGB3aW5kb3cuTUFQQk9YX0FDQ0VTU19UT0tFTiA9IHByb2Nlc3MuZW52Lk1BUEJPWF9BQ0NFU1NfVE9LRU47YDtcblxuXHQkOiBtb2JpbGUgPSB3aWR0aCA8IDU0MDtcblxuXHQkOiByZWxheGVkID0gaXNfcmVsYXhlZF9naXN0IHx8ICgkc2Vzc2lvbi51c2VyICYmIGdpc3QgJiYgJHNlc3Npb24udXNlci51aWQgPT09IGdpc3Qub3duZXIpO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0LnJlcGwtb3V0ZXIge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRoZWlnaHQ6IGNhbGMoMTAwdmggLSB2YXIoLS1uYXYtaCkpO1xuXHRcdC0tYXBwLWNvbnRyb2xzLWg6IDUuNnJlbTtcblx0XHQtLXBhbmUtY29udHJvbHMtaDogNC4ycmVtO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYmFjayk7XG5cdFx0cGFkZGluZzogdmFyKC0tYXBwLWNvbnRyb2xzLWgpIDAgMCAwO1xuXHRcdC8qIG1hcmdpbjogMCBjYWxjKHZhcigtLXNpZGUtbmF2KSAqIC0xKTsgKi9cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0fVxuXG5cdC52aWV3cG9ydCB7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHR9XG5cblx0Lm1vYmlsZSAudmlld3BvcnQge1xuXHRcdHdpZHRoOiAyMDAlO1xuXHRcdGhlaWdodDogY2FsYygxMDAlIC0gNDJweCk7XG5cdFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuM3M7XG5cdFx0ZmxleDogMTtcblx0fVxuXG5cdC5tb2JpbGUgLm9mZnNldCB7XG5cdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgMCk7XG5cdH1cblxuXHQvKiB0ZW1wIGZpeCBmb3IgIzI0OTkgYW5kICMyNTUwIHdoaWxlIHdhaXRpbmcgZm9yIGEgZml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlLXJlcGwvaXNzdWVzLzggKi9cblxuXHQudmlld3BvcnQgOmdsb2JhbCgudGFiLWNvbnRlbnQpLFxuXHQudmlld3BvcnQgOmdsb2JhbCgudGFiLWNvbnRlbnQudmlzaWJsZSkge1xuXHRcdHBvaW50ZXItZXZlbnRzOiBhbGw7XG5cdFx0b3BhY2l0eTogMTtcblx0fVxuXHQudmlld3BvcnQgOmdsb2JhbCgudGFiLWNvbnRlbnQpIHtcblx0XHR2aXNpYmlsaXR5OiBoaWRkZW47XG5cdH1cblx0LnZpZXdwb3J0IDpnbG9iYWwoLnRhYi1jb250ZW50LnZpc2libGUpIHtcblx0XHR2aXNpYmlsaXR5OiB2aXNpYmxlO1xuXHR9XG5cblx0Lnplbi1tb2RlIHtcblx0XHRwb3NpdGlvbjogZml4ZWQ7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdHRvcDogMDtcblx0XHR6LWluZGV4OiAxMTE7XG5cdH1cblxuXHQucGFuZSB7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCUgfVxuXG5cdC5sb2FkaW5nIHtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdFx0Y29sb3I6IHZhcigtLXNlY29uZCk7XG5cdFx0Zm9udC13ZWlnaHQ6IDQwMDtcblx0XHRtYXJnaW46IDJlbSAwIDAgMDtcblx0XHRvcGFjaXR5OiAwO1xuXHRcdGFuaW1hdGlvbjogZmFkZS1pbiAuNHM7XG5cdFx0YW5pbWF0aW9uLWRlbGF5OiAuMnM7XG5cdFx0YW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcblx0fVxuXG5cdEBrZXlmcmFtZXMgZmFkZS1pbiB7XG5cdFx0MCUgICB7IG9wYWNpdHk6IDAgfVxuXHRcdDEwMCUgeyBvcGFjaXR5OiAxIH1cblx0fVxuXG5cdC5pbnB1dCB7XG5cdFx0cGFkZGluZzogMi40ZW0gMCAwIDA7XG5cdH1cbjwvc3R5bGU+XG5cbjxzdmVsdGU6aGVhZD5cblx0PHRpdGxlPntuYW1lfSDigKIgUkVQTCDigKIgU3ZlbHRlPC90aXRsZT5cblxuXHQ8bWV0YSBuYW1lPVwidHdpdHRlcjp0aXRsZVwiIGNvbnRlbnQ9XCJTdmVsdGUgUkVQTFwiPlxuXHQ8bWV0YSBuYW1lPVwidHdpdHRlcjpkZXNjcmlwdGlvblwiIGNvbnRlbnQ9XCJDeWJlcm5ldGljYWxseSBlbmhhbmNlZCB3ZWIgYXBwc1wiPlxuXHQ8bWV0YSBuYW1lPVwiRGVzY3JpcHRpb25cIiBjb250ZW50PVwiSW50ZXJhY3RpdmUgU3ZlbHRlIHBsYXlncm91bmRcIj5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxzdmVsdGU6d2luZG93IGJpbmQ6aW5uZXJXaWR0aD17d2lkdGh9Lz5cblxuPGRpdiBjbGFzcz1cInJlcGwtb3V0ZXIge3plbl9tb2RlID8gJ3plbi1tb2RlJyA6ICcnfVwiIGNsYXNzOm1vYmlsZT5cblx0PEFwcENvbnRyb2xzXG5cdFx0e2dpc3R9XG5cdFx0e3JlcGx9XG5cdFx0YmluZDpuYW1lXG5cdFx0YmluZDp6ZW5fbW9kZVxuXHRcdG9uOmZvcmtlZD17aGFuZGxlX2Zvcmt9XG5cdC8+XG5cblx0eyNpZiBwcm9jZXNzLmJyb3dzZXJ9XG5cdFx0PGRpdiBjbGFzcz1cInZpZXdwb3J0XCIgY2xhc3M6b2Zmc2V0PXtjaGVja2VkfT5cblx0XHRcdDxSZXBsXG5cdFx0XHRcdGJpbmQ6dGhpcz17cmVwbH1cblx0XHRcdFx0d29ya2Vyc1VybD1cIndvcmtlcnNcIlxuXHRcdFx0XHR7c3ZlbHRlVXJsfVxuXHRcdFx0XHR7cm9sbHVwVXJsfVxuXHRcdFx0XHR7cmVsYXhlZH1cblx0XHRcdFx0Zml4ZWQ9e21vYmlsZX1cblx0XHRcdFx0aW5qZWN0ZWRKUz17bWFwYm94X3NldHVwfVxuXHRcdFx0Lz5cblx0XHQ8L2Rpdj5cblxuXHRcdHsjaWYgbW9iaWxlfVxuXHRcdFx0PElucHV0T3V0cHV0VG9nZ2xlIGJpbmQ6Y2hlY2tlZC8+XG5cdFx0ey9pZn1cblx0ey9pZn1cbjwvZGl2PlxuIl0sIm5hbWVzIjpbInN0b3JlcyIsImRvTm90WmlwLnRvQmxvYiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxREFvQnFCLEdBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBSHJCLEdBQVE7Ozs7OztzQkFITixHQUFJOzs7Ozs7Ozs7Ozs7d0NBQUosR0FBSTs7Ozs7Ozs7Ozs7O3VEQUNBLEdBQUk7aURBQWdCLEdBQVEsSUFBQyxJQUFJLENBQUMsTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxREFENUMsR0FBSTs7K0VBQ0EsR0FBSTs7OzsyRUFBZ0IsR0FBUSxJQUFDLElBQUksQ0FBQyxNQUFNOzs7O29CQUU5QyxHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQWRMLE9BQU8sS0FBS0EsUUFBTTs7O1NBRWxCLE1BQU0sS0FBSyxVQUFVLENBQUMsS0FBSztLQUUvQixRQUFRLEdBQUcsS0FBSztLQUNoQixJQUFJOzs7Ozs7O2tEQUsrQixRQUFRLEdBQUcsSUFBSTtrREFBeUIsUUFBUSxHQUFHLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUg1RixJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1Z2RCxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDakIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM5QixDQUFD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
